// JavaScript Document

var dialog = null,
    show_count = 100, // TODO: setting within browser for paging
    returnPath = '',
    dialogPath = null;

// Use a closure so injection scripts cant get to these important variables, does this actually work?
// TODO: functions that take a callback and handle account information could expose closure to injection attacks
(function () {
	var accounts = null,
		master = null,
		privateKeys = null,
		workQueue = [],
		loadingStatus = {},
		queueInterval = null,
		composeInterval = null,
        hive = [];

    function workerSuccess(data, request)
    {
        if(console)
            console.log(data);
        // check for errors
        if(typeof data._status != 'undefined' &&
            data._status == 'starting')
        {
            if(typeof request.loading == 'string')
            {
                if(typeof loadingStatus[request.loading] == 'undefined')
                    loadingStatus[request.loading] = 1;
                else
                    loadingStatus[request.loading] += 1;
                loadingAnimation($(request.loading));
            }
            else if (typeof request.loading  == 'object')
            {
                for(var j in request.loading)
                {
                    if(typeof loadingStatus[request.loading[j]] == 'undefined')
                        loadingStatus[request.loading[j]] = 1;
                    else
                        loadingStatus[request.loading[j]] += 1;
                    loadingAnimation($(request.loading[j]));
                }
            }
        }
        else if(typeof data._status != 'undefined' &&
            data._status == 'done')
        {
            if(console)
                console.log('{' + data.WORKER_ID + '}' + data._status);
            if(typeof request.loading == 'string')
            {
                loadingStatus[request.loading] -= 1;
                if(loadingStatus[request.loading] == 0)
                {
                    $(request.loading + ' .loading').stop().remove();
                }
            }
            else if (typeof request.loading == 'object')
            {
                for(var i in request.loading)
                {
                    loadingStatus[request.loading[i]] -= 1;
                    if(loadingStatus[request.loading[i]] == 0)
                    {
                        $(request.loading[i] + ' .loading').stop().remove();
                    }
                }
            }
            hive.push(this);
        }
        else if(typeof data._status != 'undefined')
        {
            if(console)
                console.log('{' + data.WORKER_ID + '}' + data._status);
        }
        else
        {
            try {
                request.result.call(window, data);
            }
            catch (e)
            {
                if(console)
                    console.log(e);
            }
        }
    }

	function processQueue()
	{
        try
        {
            var requests = workQueue;
    // TODO: some sort of prioritization here, if need be
            workQueue = [];
            if(requests.length == 0)
                return;

            var worker;
            while(requests.length > 0 && (worker = hive.pop()))
            {
                worker.request = requests.pop();
                $(worker).send({type: worker.request.type, request: worker.request.request});
            }
            if(requests.length == 0)
                return;

            $.Hive.create({
                worker: '/worker.js',
                count: requests.length,
                receive: function (data) {
                    workerSuccess.call(this, data, this.request);
                },
                created: function ($hive) {
                    var worker;
                    while ((worker = $hive.pop()))
                    {
                        worker.request = requests.pop();
                        $(worker).send({type: worker.request.type, request: worker.request.request});
                    }
                }
            });
        }
        catch (e)
        {
            if(console)
                console.log(e);
        }
	}
	
	function queueWork(item)
	{
		workQueue.push(item);
	}
	window['queueWork'] = queueWork;
	
	function encryptAccounts()
	{
		if(master != null)
		{
			var serialized = JSON.stringify(accounts),
			    result = CryptoJS.TripleDES.encrypt(serialized, master);
			localStorage['accounts'] = result.toString();
		}
		else
			localStorage['accounts'] = JSON.stringify(accounts);
		
		if(master != null)
		{
			// encrypt private keys
			serialized = JSON.stringify(privateKeys);
			result = CryptoJS.TripleDES.encrypt(serialized, master);
			encrypted = result.toString();
			localStorage['keys'] = encrypted;
		}
		else
			localStorage['keys'] = JSON.stringify(privateKeys);
	}
	
	function decryptAccounts()
	{
		var encrypted = localStorage['accounts'];
		if(typeof encrypted != 'undefined')
		{
			try {
				accounts = JSON.parse(encrypted);
			}
			catch (e) {
				try
				{
					var result = CryptoJS.TripleDES.decrypt(encrypted, master);
					var decrypted = result.toString(CryptoJS.enc.Latin1);
					accounts = JSON.parse(decrypted);
				}
				catch(e2)
				{
					// TODO:  failed to decrypt, do something here
					accounts = [];
				}
			}
		}
		else
			accounts = [];
		
		// decrypt keys too
		encrypted = localStorage['keys'];
		if(typeof encrypted != 'undefined')
		{
			try {
				privateKeys = JSON.parse(encrypted);
			}
			catch (e) {
				try
				{
					result = CryptoJS.TripleDES.decrypt(encrypted, master);
					decrypted = result.toString(CryptoJS.enc.Latin1);
					privateKeys = JSON.parse(decrypted);
				}
				catch(e2)
				{
					// TODO:  failed to decrypt, do something here
					privateKeys = [];
				}
			}
		}
		else
			privateKeys = [];
	}
	
	function getAccessCode(user, callback)
	{
		for(var i in accounts)
		{
			if(accounts[i].user == user)
			{
				if (accounts[i].user.match(/@gmail.com/igm) != null &&
					typeof accounts[i].expires != 'undefined' &&
					// check if a renewal is necessary
                    accounts[i].expires < new Date().getTime())
				{
					doGoogleLogin(accounts[i].user /* immediately */, function (account) {
						accounts[i].user = account.user;
						accounts[i].access = account.access;
						accounts[i].expires = account.expires
						encryptAccounts();
						callback.call(this, account.access, user);
					});
					return; // the callback will call this again instead
				}
				
				callback.call(this, accounts[i].pass || accounts[i].access, user);
				break;
			}
		}
	}
	
	function decryptWorker(request, resulted)
	{
		// TODO: nothing can scrape a web Worker right?
		request['keys'] = privateKeys;
		queueWork({type: 'decrypt', request: request, result: resulted});
	}
	window['decryptWorker'] = decryptWorker;
	
	function checkHash() 
	{
		if(window.location.hash == dialog)
			return;
			
		dialog = window.location.hash;
		var user = (dialog.split('#')[1] || '').split('$')[0],
			path = (dialog.split('#')[1] || '').split('$')[1],
			id = dialog.split('#')[2],
			folder,
			message = null,
			fString = '#' + encodeURIComponent(user) +
				(typeof path != 'undefined' && path != '__--compose' &&
                    path != '__--contact' ? ('$' + encodeURIComponent(path)) : '');
	
		// drag and drop area
        $('body').on('dragenter', function () {
            $('body').addClass('drag');
        });
        $('body').on('dragleave', function () {
            $('body').removeClass('drag');
        });
        $('body').on('drop', function(e) {
			// this.className = '';
			e.preventDefault();
			
			var files = e.dataTransfer.files;
			for (var i = 0; i < files.length; i++) {
				handleFileDrop(files[i]);
			}
		});
		
		// if its empty show intro
		if(dialog == '')
		{
			$('.dialog').hide();
			$('#intro').show();
			$('.message').hide();
			$('#paging').hide();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');
			return;
		}
		
		// if it's mail, hide all dialogs and overlay
		if (dialog == '#mail')
		{
			$('.dialog').hide();
			$('#mail').show();
			$('.message').hide();
			$('#paging').show();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');

			if(!(returnPath == '' || returnPath == '#intro' ||
				returnPath == '#how' || returnPath == '#login' ||
				returnPath == '#mail' || returnPath == '#keys'))
			{
				window.location.hash = returnPath;
				return; // fall to no folders if this doesn't hit
			}
		}
		
		// try to match has to known dialog
		if(dialog == '#intro' || dialog == '#how' || 
			dialog == '#login' || dialog == '#keys')
		{
			$('.dialog').hide();
			$(dialog).show();
			$('.message').hide();
			$('#paging').hide();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');
			return;
		}
		
		// load mailboxes seperately
		for(var i in accounts)
		{
            (function (root, selected, path, fString)
            {
                var isNew = root.find('ul li').length == 0;
                // make current folder request
                if(isNew || selected)
                {
                    getAccessCode(accounts[i].user, function (access, user2) {
                        queueWork({
                            type: 'mail',
                            request: {
                                user: user2,
                                path: selected && path != '__--compose' &&
                                    path != '__--contact' ? path : '',
                                access:access
                            },
                            result: function (result) {
                                mailSuccess(result, root, fString);
                            },
                            loading: ['#menubar', '#folders a[href="' + (selected ? fString : ('#' + encodeURIComponent(user2))) + '"]']
                        });
                        if(user2.match(/@gmail.com/igm) != null && isNew)
                            queueWork({
                                type: 'google',
                                request: {user: user2, access: access},
                                result: getContactsSuccess});
                    });
                }
                // if the user is equal to what we typed in in the address bar, then also load the path
            })(loadAccount(accounts[i].user), user == accounts[i].user && dialogPath != fString, path, fString);
		}
        dialogPath = fString;

		// do the visual part of the folder loading
		if((folder = $('#folders a[href="' + fString + '"]')).length > 0)
		{
			$('.dialog').hide();
			$('#mail').show();
			$('#paging').show();
			if(folder.parent().find('> ul > li').length == 0 &&
				typeof id == 'undefined')
            {
				$('body').removeClass('menu');
                $('#results').remove();
                $('#search input').val('');
            }
			// only do this if it is not selected, maybe just the message id changed, handled below
			if(!folder.is('.selected'))
			{
				var last = $('#folders .selected').removeClass('selected');
				if(!folder.parents('ul').is(last.find('~ ul')))
					last.find('~ ul').removeClass('expand');
				folder.addClass('selected');
				folder.scrollintoview();
			}
			
			// select the header in the list
			if(typeof id != 'undefined' && 
				(message = $('a[href="' + fString + '#' + id + '"]')).length > 0)
			{
				// is the link referring to an exact message
				message.removeClass('unseen').addClass('selected');
				message.scrollintoview();
			}
		}
		
		// we may be loading a message
		// let the server notify us if no message exists
		//   validation of hash is done server side
		if(typeof id != 'undefined')
		{
            var mString = '#' + encodeURIComponent(user) +
                (path != null && path != '' ? ('$' + encodeURIComponent(path)) : '') +
                '#' + encodeURIComponent(id);
			$('.dialog').hide();
			$('.message').show();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');

			// check if the message is already open, just switch to it
			if((message = $('.message a[href="' + mString + '"]')).length > 0)
			{
				var msg = message.parents('.message');
				msg.detach().appendTo($('#content'));
				if(msg.is('.compose') || msg.is('.contact'))
					$('#paging').hide();
			}
			
			// load compose mail from localStorage
			else if (path == '__--compose')
			{
				$('#paging').hide();
                (function (compose)
                {
                    getAccessCode(user, function (access, user) {
                        queueWork({
                            type: 'mail',
                            request: {user: user, path: path, access: access, id: id},
                            result: function (result)
                            {
                                composeSuccess(result, compose);
                            }
                        });
                    });
                })(loadComposition(mString));
			}

            // view a contact
            else if (path == '__--contact')
            {
                var contact;
                if((contact = $('#contacts a[href="' + mString + '"]')).length > 0)
                    loadContact(user, id, contact.data('contact'));
                (function (contact)
                {
                    getAccessCode(user, function (access, user) {
                        queueWork({
                            type: 'google',
                            request: {user: user, access: access, id: id},
                            result: function (result) {
                                contact.find('tbody pre').text(JSON.stringify(result[0].data, undefined, 4));
                                contact.find('tr:first-child th:nth-child(2) a span').text(result[0].title);
                            }
                        });
                    });
                })(loadContact(user, id));
            }

			// load the message from the associated account
			else
                (function(mString)
                {
                    getAccessCode(user, function (access, user) {
                        queueWork({
                            type: 'mail',
                            request: {user:user, path: path, id: id, access:access},
                            result: function (result) {
                                messageSuccess(result, mString);
                            },
                            loading: '#menubar'
                        });
                    });
                })(mString);
		}
		else
			$('.message').hide();
	}
	
	function populateAccounts(j)
	{
		for(var i in accounts)
			j.append('<option value="' + accounts[i].user + '">' + accounts[i].user + '</option>');
	}
	window['populateAccounts'] = populateAccounts;
	
	function sendMessage(addresses, from, message, subject, which)
	{
		var publicKeys = [],
			keys = privateKeys,
			pubs = openpgp.keyring.publicKeys,
			unknowns = [],
			privateKey = null;
		
		// find private key for the selected sender
		for(var j in keys)
		{
			var key = openpgp.read_privateKey(keys[j])[0];
			// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
			if(key.userIds[0].text.indexOf(from) > -1)
			{
				privateKey = keys[j];
				break;
			}
		}
		
		// add all the recipients to the encrypted message
		for(var j in addresses)
		{
			var hit = false;
			for(var i in pubs)
			{
				if(pubs[i].obj.userIds[0].text.indexOf(addresses[j]) > -1)
				{
					publicKeys[publicKeys.length] = pubs[i].obj;
					hit = true;
					break;
				}
			}
			if(!hit)
			{
				unknowns[unknowns.length] = addresses[j];
			}
		}
		
		if(unknowns.length > 0)
		{
			// TODO: display a message when there are unknown recipients, ask to invite them
		}
		
		// TODO: fix plain text by iterating dom
		var request = {
			publicKeys: publicKeys,
			privateKey: privateKey,
			message: message,
			subject: subject,
			from: from,
			recipients: addresses
		};
		
		queueWork({type: 'send', request: request, result: 'sent', loading: which})
	}
	window['sendMessage'] = sendMessage;
	
	function addAccount(account)
	{
		var hit = false;
		for(var i in accounts)
		{
			if(accounts[i].user == account.user)
			{
				accounts[i].pass = account.pass;
				hit = true;
			}
		}
		if(!hit)
			accounts[accounts.length] = account;
		// store the accounts
		encryptAccounts();
	}
	
	function setBindings(scope)
	{
		if(scope == null)
			scope = $('body')
		
		scope.find('a[href="#folders"]').click(function (evt) {
			evt.preventDefault();
			$('#folders .selected').scrollintoview();
		});
		
		scope.find('a[href="#login-google"]').click(function (evt) {
			evt.preventDefault();
			doGoogleLogin();
		});
		
		scope.find('a[href="#keys"]').click(function () {
			// TODO: remove this, only offer a download uri, can that be called by a javascript and exploited?
			for(var i in accounts)
			{
				var fString = accounts[i].user;
				
				// only add account keys once
				if($('#keys .keys a[href="#' + fString + '"]').length > 0)
					continue;
				
				var email = $('<li><a href="#' + fString + '">' + fString + '</a></li>');
				email = email.appendTo($('#keys .keys ul'))
							 .find('a');
				email.click(function (evt) {
					evt.preventDefault();
					var fString = $(this).attr('href').substring(1);
					// do visual selection stuff
					$('#keys .selected').removeClass('selected');
					$(this).addClass('selected');
					
					// clear currently displayed key
					$('#key').val('');
					
					// find key in keyring that matches the email address
					// TODO: connect this to some backup or management server
					var keys = privateKeys,
						result = '';
					for(var j in keys)
					{
						var key = openpgp.read_privateKey(keys[j])[0];
						// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
						if(key.userIds[0].text.indexOf(fString) > -1)
						{
							result += (result != '' ? '\r\n' : '') + keys[j];
							break;
						}
					}
					
					keys = openpgp.keyring.publicKeys;
					for(var j in keys)
					{
						// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
						if(keys[j].obj.userIds[0].text.indexOf(fString) > -1)
						{
							result += (result != '' ? '\r\n' : '') + keys[j].armored;
							break;
						}
					}
					
					// if there are no keys, offer create button
					if(result == '')
					{
						$('#keys th:nth-child(2), #keys td:nth-child(2)').hide();
						$('#keys th:nth-child(3), #keys td:nth-child(3)').show();
					}
					else
					{
						$('#key').val(result);
						$('#keys th:nth-child(2), #keys td:nth-child(2)').show();
						$('#keys th:nth-child(3), #keys td:nth-child(3)').hide();
					}
				});
			
				// synchronize public keys for trusted users
			}
		});
		
		scope.find('a[href="#create-key"]').click(function (evt) {
			evt.preventDefault();
			var fString = $('#keys .selected').attr('href').substring(1),
				//salt = openpgp_crypto_getRandomBytes(8),
				request = { // TODO: make options on the #keys page out of these
					size: 2048,
					name: '<' + fString + '>'
					//pass: master,
				},
				keyResponse = function () {
					if(typeof data.privateKeyArmored != 'undefined')
					{
						privateKeys[privateKeys.length] = data.privateKeyArmored;
						// import result in to local keyring
						openpgp.keyring.importPublicKey(data.publicKeyArmored);
						encryptAccounts();

						// if the same userId is still selected, show the key text
						if($('#keys .selected').attr('href') == '#' + fString)
						{
							$('#key').val(data.publicKeyArmored + data.privateKeyArmored);
							$('#keys th:nth-child(2), #keys td:nth-child(2)').show();
							$('#keys th:nth-child(3), #keys td:nth-child(3)').hide();
						}
					}
				};
			
			queueWork({type: 'generate', request: request, result: keyResponse, loading: '#keys'})
		});
		
		scope.find('a[href="#login"]').click(function (evt) {
			// list google accounts on login page
			var aLink = null;
			for(var i in accounts)
			{
				if($('#login a[href="#' + accounts[i].user + '"]').length != 0)
					continue;
				
				if(accounts[i].user.match(/@gmail.com$/igm) != null)
					$('#accounts').append('<p><a href="#' + accounts[i].user + '" class="little-btn google">g</a>signed in as ' + accounts[i].user + '</p>');
				else
					$('#accounts').append('<p><a href="#' + accounts[i].user + '" class="little-btn imap">imap</a>signed in as ' + accounts[i].user + '</p>');
			}
		});
		
		scope.find('a[href="#write"]').click(function (evt) {
			evt.preventDefault();
			var firstId = function (user) {
					var id = 1,
						fString = '#' + user +
						'$__--compose' +
						'#' + id;
					while($('.message a[href="' + fString + '"]').length > 0 && typeof localStorage[fString] == 'undefined')
						id++;
					return id;
            },
                mString = '#' + accounts[0].user +
                          '$' + '__--compose' +
                          '#' + firstId(accounts[0].user);
            loadComposition(mString);
            window.location.hash = mString;
		});
		
		scope.find('a[href="#login-other"]').click(function (evt) {
			evt.preventDefault();
	
			// encode as base64 and send to proxy
			//   TODO: can this be done in javascript and there is no need for a proxy?
			var $base64 = CryptoJS.enc.Latin1.parse($('#pass').val()).toString(CryptoJS.enc.Base64),
				email = $('#email').val();
			$.post('/login.php', {
				user:email,
				access:$base64
			}, function (data) {
				// save in accounts
				var account = {user: email, pass: $base64};
				addAccount(account);
				
				// load the new mailbox
				returnPath = '#' + account.user;
				window.location.hash = '#mail';
			})
			.fail(function (data) {
				master = null;
// TODO: display error message
				
			});
		});
	}
	
	function firstLoad()
	{
		openpgp.init(); //must call here :/  shouldn't it just do this when it's done loading?

		composeInterval = setInterval(function () {
			var last = $('.compose').last();
			if(last.length == 0)
				return;
            var headers = $($('#menubar, .message thead').toEnumerable().Union(last.find('.jqte_toolbar:not(:hidden), .jqte_linkform:not(:hidden)').toEnumerable()).ToArray()),
                editor = last.find('.jqte'),
                height = 0;
            headers.each(function () {
                height += $(this).outerHeight();
            })
            editor.css('min-height', $(window).innerHeight() - height);
		}, 100);
		queueInterval = setInterval(processQueue, 100);
		
		// initialize everything using functions from mail.js
		$(window).on('hashchange', checkHash);
		
		decryptAccounts(); // decrypt local account information
		
		var params = {}, 
			queryString = window.location.hash.substring(1),
			regex = /([^&=]+)=([^&]*)/g, m;
		while (m = regex.exec(queryString)) {
			params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
		}
		
		if(typeof params['state'] != 'undefined' &&
			params['state'] == 'initialGoogle')
			getGoogleUser(params, function (account) {
				addAccount(account);
				returnPath = '#' + account.user;
				window.location.hash = '#mail';
			});
		else
			returnPath = window.location.hash;
		
		if(accounts.length > 0)
			window.location.hash = '#mail';
		else
			window.location.hash = '#intro';
		
		// fire hash changed at least once
		$(window).trigger('hashchange');
					
		setBindings();

        var searchBubble = {title: "Press ENTER for full search."},
            menuBubble = {title: "Click HERE for menu."};

        $('#search input').val('').watermark('Search      ');
        $('#search input').keyup(function () {
            var search = $(this).val().trim(),
                results = $('#results'),
                matches = new RegExp(search, 'igm');
            if(search == '')
                $('#results').remove();
            if(results.length == 0)
                results = $('<ul id="results"></ul>').insertAfter($('#search'));
            else
                results.find('>*').remove();
            $('#nav a').each(function () {
                if(matches.test($(this).text()))
                {
                    $(this).clone().html($(this).text()
                        .replace(matches, function (match) { return '<span class=\"highlight\">' + match + '</span>'; }))
                        .appendTo($('<li></li>').appendTo(results));
                }
            });
        }).focus(function () {
            showBubble.call($(this), searchBubble);
            setTimeout(function () {
                if(searchBubble.bubble)
                    searchBubble.bubble.remove();
            }, 3000);
        });

		$('a[href="#menu"]').click(function (evt) {
			evt.preventDefault();
			$('body').toggleClass('menu');
		});

        setTimeout(function () {
            showBubble.call($('#menubar h1'), menuBubble);
            setTimeout(function () {
                if(menuBubble.bubble)
                    menuBubble.bubble.remove();
            }, 3000);
        }, 1000);
	}
	$(document).ready(function () {
		firstLoad();
	});
})();

function refreshBody(result, message)
{
	// TODO:  implement levels of trust for content
	// only make view/display decisions here, nothing to do with data structure
	
	for(var i in result)
	{
		var headers = result[i]['headers'],
			// add parts to message
			part = message.find('.part[id="' + headers['part-id'] + '"]');
			
		if(part.length == 0)
			part = $('<div class="part" id="{part-id}" class="{encrypted} {decrypted} {verified}"></div>'
                         .replace(/\{encrypted\}/igm, typeof headers['encrypted'] != 'undefined' ? 'encrypted' : '')
                         .replace(/\{decrypted\}/igm, typeof headers['decrypted'] != 'undefined' ? 'decrypted' : '')
                         .replace(/\{verified\}/igm, typeof headers['verified'] != 'undefined' ? 'verified' : '')
         				 .replace(/\{part-id\}/igm, headers['part-id']))
				.appendTo(message.find('tbody td'));
		if(typeof headers['content-type'] != 'undefined')
			part.addClass(sanitizeName(headers['content-type']));
		
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'application/octet-stream')
		{
			// create a link to blob to download file
		}
		if(result[i]['headers']['content-type'] == 'pgp/mime')
		{
			// notify users that they have received and encrypted message
		}
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'text/plain')
		{
			// html encode
			var output = escapeHtml(result[i].body, true);
			// wrap in a pre tag
			part.html('<pre>' + output + '</pre>');
		}
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'text/html')
		{
			// assume html and just wrap in a div
			var output = sanitizeBody(result[i].body);
			part.html(output);
		}
		if(typeof headers['parameters'] != 'undefined' && (
			typeof headers['parameters']['name'] != 'undefined' ||
			typeof headers['parameters']['attachment'] != 'undefined' ||
			typeof headers['parameters']['filename'] != 'undefined'))
		{
			// add to DOM as attachment
			var filename = headers['parameters']['name'] || headers['parameters']['attachment'] || 
						   headers['parameters']['filename'];
			// display a save link to file
			var attachment = message.find('.attachments .' + sanitizeName(filename));
			if(attachment.length == 0)
                attachment = $('<div class="' + sanitizeName(filename) + '">' + filename + '<a href="' + headers['part-id'] + '">download</a></div>')
                    .appendTo(message.find('.attachments'));
		}
		
		// add encrypted loading symbol
        /* what is the purpose of this? && (
        headers['content-type'] != 'text/plain' ||
        headers['content-type'] != 'text/html') */
        if(message.find('.decrypting').length == 0 &&
            message.find('.encrypted').length > message.find('.decrypted, .verified').length)
            $('<div class="decrypting">decrypting...</div>').prependTo(message.find('.attachments'));
        else
            message.find('.decrypting').remove();

		// add symbols for parts of message
		if(typeof headers['verified'] != 'undefined' &&
			headers['verified'] == false)
		{
			if(message.find('.verify-failed').length == 0)
				$('<tr><th class="verify-failed" colspan="3"><div>Signature varification failed.</div></th></tr>').appendTo(message.find('thead'))
		}
		
		// add decryption failed message here, just like above
		if(typeof headers['decrypt'] != 'undefined' &&
			headers['decrypt'] == false)
		{
			if(message.find('.decryption-failed').length == 0)
				$('<tr><th class="decryption-failed" colspan="3"><div>Decryption failed.</div></th></tr>').appendTo(message.find('thead'))
		}
		
		// select the best view based on trust level

	}
	
}

function refreshDraft(result, compose)
{
    // TODO:  implement levels of trust for content
    // only make view/display decisions here, nothing to do with data structure

    for(var i in result)
    {
        var headers = result[i]['headers'];

        if(typeof headers['content-type'] != 'undefined' &&
           headers['content-type'] == 'text/plain')
        {
            // assume html and just wrap in a div
            compose.find('textarea').jqteVal(
                attachments[i].body
                    .replace(/\r*\n/igm, '<br />')
            );
        }
        if(typeof headers['content-type'] != 'undefined' &&
           headers['content-type'] == 'text/html')
        {
            // assume html and just wrap in a div
            compose.find('textarea').jqteVal(attachments[i].body);
        }
    }
}

function loadingAnimation(that)
{
	if(typeof that != 'undefined' && that.length > 0 && that.find('.loading').length == 0)
	{
		return loadingAnimation.call($('<span class="loading">&nbsp;</span>').appendTo(that), that);
	}
	else if ($(this).is('.loading'))
		return $(this).css('width', 0).css('left', 0)
			.animate({width: $(this).parent().outerWidth(true)}, 1000, function () {
				$(this).animate({left: $(this).parent().outerWidth(true)}, 1000, loadingAnimation);
			});
	else if(typeof that != 'undefined')
		return that.find('.loading');
}

function closeMessage(evt)
{
	evt.preventDefault();
	var that = $(this),
		message = that.parents('.message'),
		fString = that.parents('tr').find('th:nth-child(2) a').attr('href'),
		prev = message.prev('#content .message');
	message.remove();
	$('#mail a[href="' + fString + '"]').removeClass('selected');
	if(prev.length == 0)
	    // if the user closes the first message skip to the last message
		prev = $('#content .message').last();

	// if we closed the last message, select the current folder
	if(prev.length == 0)
		window.location.hash = $('#folders .selected').attr('href');
	// if we haven't closed all the message, select the next one in order
	else if(window.location.hash == fString)
		window.location.hash = prev.find('thead th:nth-child(2) a').attr('href');
}

function composeSuccess(result, compose)
{
    var path = result.info.mailbox.replace(/Drafts/i, ''),
        to = parseInlineEncoding(result.headers.to),
        recipients = parseInlineEncoding(result.headers.to).split(/\s*;\s*|\s*,\s*|\s+/igm);
    // fill in composition
    if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(to)))
        to = $match[2].trim();
    compose.find('tr:first-child th:nth-child(2) a').html('<span>' + escapeHtml(to) + '</span>' +
                                                          escapeHtml(parseInlineEncoding(result.headers.subject)));
    for(var i in recipients)
    {
        var match;
        if((match = matchEmail.exec(recipients)))
        {
            var contact = $('#contacts a:contains("' + match[0] + '")').parents('li'),
                title = contact.find('a').first().text();

        }
    }
    compose.find('input.recipients').val(recipients);
    compose.find('input.subject').val(parseInlineEncoding(result.headers.subject));

    // parse all the attached parts in the draft
    parseMIME('', result.headers, function (result) {
        refreshDraft(result, compose);
    });
}

function messageSuccess(result, mString)
{
    var path = result.info.mailbox,
        from = parseInlineEncoding(result.headers.from),
        allHeaders = null,
        template = $('#templates .message:not(.compose, .contact)').clone(),
        $match;

    // remove extra information on from
    if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(from)))
        from = $match[2].trim();
    var message = template.html(template.html().replace(/\{from\}/ig, escapeHtml(from))
                                    .replace(/\{fromfull\}/ig, escapeHtml(parseInlineEncoding(result.headers.from)))
                                    .replace(/\{subject\}/ig, escapeHtml(parseInlineEncoding(result.headers.subject)))
                                    .replace(/\{date\}/ig, escapeHtml(parseInlineEncoding(result.headers.date)))
                                    .replace(/\{to\}/ig, escapeHtml(parseInlineEncoding(result.headers.to)))
                                    .replace(/\{link\}/ig, mString));
    message.appendTo($('#content'));
    message.find('a[href="#close-message"]').click(closeMessage);
    message.find('a[href="#reply"]').parent().parent().hover(function () {
        $(this).addClass('hover');
    }, function () {
        $(this).removeClass('hover');
    });
    message.find('a[href="#text_plain"], a[href="#text_html"]').click(function (evt) {
        evt.preventDefault();
        message.find('.part').hide();
        message.find('.part.' + $(this).attr('href').substring(1)).show();
    });
    message.find('a[href="#all_headers"]').click(function (evt) {
        evt.preventDefault();
        if(allHeaders == null)
        {
            allHeaders = [];
            var sorter = [];
            for(var i in result.headers)
            {
                if(typeof result.headers[i] != 'string' || i == 'from' || i == 'date' || i == 'to')
                    continue;
                sorter[sorter.length] = i;
            }
            sorter.sort(function (a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            for(var j in sorter)
            {
                var key = sorter[j].replace(/(^|-)[a-z]/igm, function ($0) {
                    return $0.toUpperCase();
                });
                allHeaders[allHeaders.length] = $('<span><span>' + escapeHtml(parseInlineEncoding(key)) +
                                                  '</span>' + escapeHtml(parseInlineEncoding(result.headers[sorter[j]])) +
                                                  '</span>').appendTo(newMessage.find('.headers'))[0];
            }
        }
        else
            $(allHeaders).toggle();
    });
    message.find('a[href="#reply"]').click(function (evt) {

    });
    // clean up the email data
    /*if(result.headers.size >= 4 * 1024 * 1024)
     {
     // the message is large, download with a worker
     getAccessCode(result.user + '@' + result.host, function (access) {
     var request = {
     user:result.user + '@' + result.host,
     path: path,
     access: access,
     id : result.headers.msgno,
     headers : {
     'part-id' : mString
     }
     };
     queueWork({type: 'download', request: request, result: refreshBody});
     });

     }
     else*/

    parseMIME('', result.headers, function (result) {
        refreshBody(result, message);
    });

}

// called whenever the page is first loaded and we need to
//   list the mail folders and headers for the selected folder
function mailSuccess(result, root, fString)
{
	var folders = $('#folders');

	// reload the folders from account
	if(typeof result.folders != 'undefined' && result.folders != null)
    {
        root.data('folders', result.folders);
		loadFolders(root, result.folders);
    }
	
	// if we just loaded the currently selected folder
	var dialog = window.location.hash,
		user = dialog.split('#')[1].split('$')[0],
		path = dialog.split('#')[1].split('$')[1],
		sString = '#' + encodeURIComponent(user) + (typeof path != 'undefined' && path != '__--compose' &&
                                 path != '__--contact' ? ('$' + encodeURIComponent(path)) : '');
	if($('#folders .selected').length == 0 && dialog == '#mail')
	{
		window.location.hash = sString = fString;
	}
	var selected = $('#folders a[href="' + sString + '"]'),
		fLink = $('#folders a[href="' + fString + '"]');
	if(fLink.length > 0)
	{
		fLink.text(fLink.text().replace(/\s+\([0-9]*\)\s*$/i, '') + ' (' + result.info.unseen + ')');
	}
	
	// load the headers in to the message list, 
	//   only when the headers are of the mailbox we selected
	//   like the scenario when we load all the folder first time the page loads
	//   or when the user selects a different folder while its loading
	if(selected.length > 0)
	{
		selected.addClass('selected').parents('ul').addClass('expand');
		selected.scrollintoview();
		if(sString == fString)
		{
			// set up paging
			$('#count').html('<b>' + (1+result.info.start) + '-' + result.info.end + '</b> of <b>' + result.info.messages + '</b>');
			loadHeaders(result, fString, result.headers);
		}
	}
}

function loadFolders(root, folders)
{
	folders.sort(function (a, b) {
		return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
	});

    for(var i in folders)
	{
		// split by dot to create folder trees
		var subfolders = folders[i].name.split(folders[i].delim),
			current = root.children('ul'),
            currentString = root.find('a').attr('href') + '$';

		// loop through each sub folder adding as we go
		for(var j in subfolders)
		{
            currentString += encodeURIComponent((j > 0 ? folders[i].delim : '') + subfolders[j]);
			var temp = current.find('> li > a[href="' + currentString + '"]').parent();
			if(temp.length == 0)
			{
				temp = $('<li><a href="' + currentString + '">' + subfolders[j] + '</a><ul></ul></li>')
				.appendTo(current);
				temp.find('> a')
				.click(function () {
					$(this).siblings('ul').toggleClass('expand');
				});
			}
			current = temp.children('ul');
		}
	}
}

function loadHeaders(result, fString, headers)
{
	$('#mail a').remove();
	
	for(var header in headers)
	{
		if(!headers[header]) // skip messages that disappeared
			continue;
		if(typeof headers[header] == 'object')
		{
			var obj = headers[header],
                // this is the path directly to the message,
                mString = fString + '#' + encodeURIComponent(obj.msgno),
				selected = $('.message a[href="' + mString + '"]').length > 0;
			
			if(obj.from == null)
				obj.from = '';
			else
				obj.from = parseInlineEncoding(obj.from);
			// remove extra information on from
			if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(obj.from)))
				obj.from = $match[2].trim();
			
			if(obj.subject == null)
				obj.subject = '';
			else
				obj.subject = parseInlineEncoding(obj.subject);
			
			var newRow = $('<a href="' + mString + '" class="' + (selected ? 'selected' : '') + '"><span>&nbsp;</span>' +
				'<span>' + escapeHtml(obj.from) + '</span>' +
				'<span>' + escapeHtml(obj.subject) + '</span>' +
				'<span>' + obj.date + '</span></a>').appendTo($('#mail'));
			
			if(!(/\\seen/i).test(obj.flags))
				newRow.addClass('unseen');
		}
	}
}

function loadContact(user, id, contact, mString)
{
    var template = $('#templates .message.contact').clone();
    var newMessage = template.html(template.html()
                           .replace(/\{link\}/ig, mString)
                           .replace(/\{title\}/ig, contact.length > 0 ? contact.text() : '')
                           .replace(/\{contact\}/ig, contact.length > 0 ? JSON.stringify(contact.data('data'), undefined, 4) : ''));
    newMessage.appendTo($('#content'));
    newMessage.find('a[href="#close-message"]').click(closeMessage);
    return newMessage;
}

function loadAccount(user)
{
    var root = $('#folders a[href="#' + encodeURIComponent(user) + '"]').parent(),
        folders = $('#folders');
    if(root.length == 0)
    {
        root = $('<li><a href="#' +  encodeURIComponent(user) + '">' + escapeHtml(user) + '</a><ul class="expand"></ul></li>')
            .appendTo(folders);
        root.find('> a')
            .click(function () {
                // uncomment to allow accountRoot to be minimized
                //$(this).siblings('ul').toggleClass('expand');
            });

    }
    return root;
}

function loadComposition(mString)
{
    var template = $('#templates .message.compose').clone();
	var compose = template.html(template.html()
        .replace(/\{link\}/ig, mString)
        .replace(/\{to\}/ig, 'New message')
        .replace(/\{subject\}/ig, '')
        .replace(/\{message\}/ig, ''));
    compose.appendTo($('#content'));
	populateAccounts(compose.find('.from'));  // call a different scope to add users
    compose.find('.recipients').watermark('To      ');
    compose.find('.subject').watermark('Subject      ');
    compose.find('textarea').jqte();
    compose.find('a[href="#close-message"]').click(closeMessage);
    compose.find('a[href="#format"]').click(function (evt) {
        evt.preventDefault();
        $(this).toggleClass('checked');
        $(this).parents('.compose').find('.jqte').toggleClass('checked');
    });
    compose.find('a[href="#attach"]').click(function (evt) {
		evt.preventDefault();
	});
    compose.find('a[href="#send"]').click(function (evt) {
		evt.preventDefault();
		var compose = $(this).parents('.compose');
		sendMessage(
			compose.find('.recipients').val().split(/\s*;\s*|\s*,\s*|\s+/igm),
			compose.find('select').val(),
			compose.find('textarea').val(),
			compose.find('.subject').val(),
			mString);
			
		compose.addClass('sending');
	});
    compose.find('a[href="#encrypt"]').click(function (evt) {
		evt.preventDefault();
		$(this).toggleClass('checked');
	});

    compose.find('a[href="#sign"]').click(function (evt) {
		evt.preventDefault();
		$(this).toggleClass('checked');
	});
    return compose;
}

function showBubble(vars)
{
    vars.css = 'jqte';
    if(vars.title)
    {
        if(vars.bubble)
            vars.bubble.remove();

        // create the title bubble
        vars.bubble = $('<div class="'+vars.css+'_title"><div class="'+vars.css+'_titleArrow"><div class="'+vars.css+'_titleArrowIcon"></div></div><div class="'+vars.css+'_titleText">'+vars.title+'</div></div>').insertAfter($(this));

        var thisArrow = vars.bubble.find('.'+vars.css+'_titleArrowIcon');
        var thisPosition = $(this).position();
        var thisAlignX = thisPosition.left + $(this).outerWidth() - (vars.bubble.outerWidth()/2) - ($(this).outerWidth()/2);
        var thisAlignY = (thisPosition.top + $(this).outerHeight() + 5);

        // show the title bubble and set to its position
        vars.bubble.delay(400).css({'top':thisAlignY, 'left':thisAlignX}).fadeIn(200);
    }
}


