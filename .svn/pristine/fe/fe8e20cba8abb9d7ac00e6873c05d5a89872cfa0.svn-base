// JavaScript Document

var dialog = null,
    show_count = 100, // TODO: setting within browser for paging
    returnPath = '',
    dialogPath = null;

// Use a closure so injection scripts cant get to these important variables, does this actually work?
// TODO: functions that take a callback and handle account information could expose closure to injection attacks
(function () {
	var accounts = null,
		master = null,
		privateKeys = null,
		workQueue = [],
		loadingStatus = {},
		queueInterval = null,
		composeInterval = null,
        hive = [];

    function workerSuccess(data, request)
    {
        if(console)
            console.log(data);
        // check for errors
        if(typeof data._status != 'undefined' &&
            data._status == 'starting')
        {
            if(typeof request.loading == 'string')
            {
                if(typeof loadingStatus[request.loading] == 'undefined')
                    loadingStatus[request.loading] = 1;
                else
                    loadingStatus[request.loading] += 1;
                loadingAnimation($(request.loading));
            }
            else if (typeof request.loading  == 'object')
            {
                for(var j in request.loading)
                {
                    if(typeof loadingStatus[request.loading[j]] == 'undefined')
                        loadingStatus[request.loading[j]] = 1;
                    else
                        loadingStatus[request.loading[j]] += 1;
                    loadingAnimation($(request.loading[j]));
                }
            }
        }
        else if(typeof data._status != 'undefined' &&
            data._status == 'done')
        {
            if(console)
                console.log('{' + data.WORKER_ID + '}' + data._status);
            if(typeof request.loading == 'string')
            {
                loadingStatus[request.loading] -= 1;
                if(loadingStatus[request.loading] == 0)
                {
                    $(request.loading + ' .loading').stop().remove();
                }
            }
            else if (typeof request.loading == 'object')
            {
                for(var i in request.loading)
                {
                    loadingStatus[request.loading[i]] -= 1;
                    if(loadingStatus[request.loading[i]] == 0)
                    {
                        $(request.loading[i] + ' .loading').stop().remove();
                    }
                }
            }
            hive.push(this);
        }
        else if(typeof data._status != 'undefined')
        {
            if(console)
                console.log('{' + data.WORKER_ID + '}' + data._status);
        }
        else
        {
            try {
                request.result.call(window, data.message || data);
            }
            catch (e)
            {
                if(console)
                    console.log(e);
            }
        }
    }

	function processQueue()
	{
        try
        {
            var requests = workQueue;
    // TODO: some sort of prioritization here, if need be
            workQueue = [];
            if(requests.length == 0)
                return;

            var worker;
            while(requests.length > 0 && (worker = hive.pop()))
            {
                worker.request = requests.pop();
                $(worker).send({type: worker.request.type, request: worker.request.request});
            }
            if(requests.length == 0)
                return;

            $.Hive.create({
                worker: '/worker.js',
                count: requests.length,
                receive: function (data) {
                    workerSuccess.call(this, data, this.request);
                },
                created: function ($hive) {
                    var worker;
                    while ((worker = $hive.pop()))
                    {
                        worker.request = requests.pop();
                        $(worker).send({type: worker.request.type, request: worker.request.request});
                    }
                }
            });
        }
        catch (e)
        {
            if(console)
                console.log(e);
        }
	}
	
	function queueWork(item)
	{
		workQueue.push(item);
	}
	window['queueWork'] = queueWork;
	
	function encryptAccounts()
	{
		if(master != null)
		{
			var serialized = JSON.stringify(accounts);
			var result = CryptoJS.TripleDES.encrypt(serialized, master);
			var encrypted = result.toString();
			localStorage['accounts'] = encrypted;
		}
		else
			localStorage['accounts'] = JSON.stringify(accounts);
		
		if(master != null)
		{
			// encrypt private keys
			serialized = JSON.stringify(privateKeys);
			result = CryptoJS.TripleDES.encrypt(serialized, master);
			encrypted = result.toString();
			localStorage['keys'] = encrypted;
		}
		else
			localStorage['keys'] = JSON.stringify(privateKeys);
	}
	
	function decryptAccounts()
	{
		var encrypted = localStorage['accounts'];
		if(typeof encrypted != 'undefined')
		{
			try {
				accounts = JSON.parse(encrypted);
			}
			catch (e) {
				try
				{
					var result = CryptoJS.TripleDES.decrypt(encrypted, master);
					var decrypted = result.toString(CryptoJS.enc.Latin1);
					accounts = JSON.parse(decrypted);
				}
				catch(e2)
				{
					// TODO:  failed to decrypt, do something here
					accounts = [];
				}
			}
		}
		else
			accounts = [];
		
		// decrypt keys too
		encrypted = localStorage['keys'];
		if(typeof encrypted != 'undefined')
		{
			try {
				privateKeys = JSON.parse(encrypted);
			}
			catch (e) {
				try
				{
					result = CryptoJS.TripleDES.decrypt(encrypted, master);
					decrypted = result.toString(CryptoJS.enc.Latin1);
					privateKeys = JSON.parse(decrypted);
				}
				catch(e2)
				{
					// TODO:  failed to decrypt, do something here
					privateKeys = [];
				}
			}
		}
		else
			privateKeys = [];
	}
	
	function getAccessCode(user, callback)
	{
		for(var i in accounts)
		{
			if(accounts[i].user == user)
			{
				if (accounts[i].user.match(/@gmail.com/igm) != null &&
					typeof accounts[i].expires != 'undefined' &&
					// check if a renewal is necessary
                    // TODO: remove true as it is just for testing
                    (true || accounts[i].expires < new Date().getTime()))
				{
					doGoogleLogin(accounts[i].user /* immediately */, function (account) {
						accounts[i].user = account.user;
						accounts[i].access = account.access;
						accounts[i].expires = account.expires
						encryptAccounts();
						callback.call(this, account.access, user);
					});
					return; // the callback will call this again instead
				}
				
				callback.call(this, accounts[i].pass || accounts[i].access, user);
				break;
			}
		}
	}
	
	function decryptWorker(request, resulted)
	{
		// TODO: nothing can scrape a web Worker right?
		request['keys'] = privateKeys;
		queueWork({type: 'decrypt', request: request, result: resulted});
	}
	window['decryptWorker'] = decryptWorker;
	
	function checkHash() 
	{
		if(window.location.hash == dialog)
			return;
			
		dialog = window.location.hash;
		var user = (dialog.split('#')[1] || '').split('$')[0],
			path = (dialog.split('#')[1] || '').split('$')[1],
			id = dialog.split('#')[2],
			folder,
			message = null,
			fString = '#' + user + 
				(typeof path != 'undefined' && path != '__--compose' &&
                    path != '__--contact' ? ('$' + path) : '');
	
		// drag and drop area
        $('body').on('dragenter', function () {
            $('body').addClass('drag');
        });
        $('body').on('dragleave', function () {
            $('body').removeClass('drag');
        });
        $('body').on('drop', function(e) {
			// this.className = '';
			e.preventDefault();
			
			var files = e.dataTransfer.files;
			for (var i = 0; i < files.length; i++) {
				handleFileDrop(files[i]);
			}
		});
		
		// if its emtpy show intro
		if(dialog == '')
		{
			$('.dialog').hide();
			$('#intro').show();
			$('.message').hide();
			$('#paging').hide();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');
			return;
		}
		
		// if it's mail, hide all dialogs and overlay
		if (dialog == '#mail')
		{
			$('.dialog').hide();
			$('#mail').show();
			$('.message').hide();
			$('#paging').show();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');

			if(!(returnPath == '' || returnPath == '#intro' ||
				returnPath == '#how' || returnPath == '#login' ||
				returnPath == '#mail' || returnPath == '#keys'))
			{
				window.location.hash = returnPath;
				return; // fall to no folders if this doesn't hit
			}
		}
		
		// try to match has to known dialog
		if(dialog == '#intro' || dialog == '#how' || 
			dialog == '#login' || dialog == '#keys')
		{
			$('.dialog').hide();
			$(dialog).show();
			$('.message').hide();
			$('#paging').hide();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');
			return;
		}
		
		// load mailboxes seperately
		for(var i in accounts)
		{
			var isNew = loadAccount(accounts[i].user),
                // if the user is equal to what we typed in in the address bar, then also load the path
                selected = user == accounts[i].user && dialogPath != fString;
            // make current folder request
			if(isNew || selected)
            {
                getAccessCode(accounts[i].user, function (access, user2) {
                    queueWork({
                        type: 'mail',
                        request: {
                            user: user2,
                            path: selected && path != '__--compose' &&
                                  path != '__--contact' ? path : '',
                            access:access
                        },
                        result: mailSuccess,
                        loading: '#menubar'
                    });
                    if(user2.match(/@gmail.com/igm) != null && isNew)
                        queueWork({
                            type: 'google',
                            request: {user: user2, access: access},
                            result: getContactsSuccess});
                });
            }
		}
        dialogPath = fString;

		// do the visual part of the folder loading
		if((folder = $('#folders a[href="' + fString + '"]')).length > 0)
		{
			$('.dialog').hide();
			$('#mail').show();
			$('#paging').show();
			if(folder.parent().find('> ul > li').length == 0 &&
				typeof id == 'undefined')
            {
				$('body').removeClass('menu');
                $('#results').remove();
                $('#search input').val('');
            }
			// only do this if it is not selected, maybe just the message id changed, handled below
			if(!folder.is('.selected'))
			{
				var last = $('#folders .selected').removeClass('selected');
				if(!folder.parents('ul').is(last.find('~ ul')))
					last.find('~ ul').removeClass('expand');
				folder.addClass('selected');
				folder.scrollintoview();
				/*var offset = folder.offset();
				$('#folders').animate({
					scrollTop: offset.top - $('#folders').offset().top
				});
				*/

			}
			
			// select the header in the list
			if(typeof id != 'undefined' && 
				(message = $('a[href="' + fString + '#' + id + '"]')).length > 0)
			{
				// is the link referring to an exact message
				message.removeClass('unseen').addClass('selected');
				message.scrollintoview();
			}
		}
		
		// we may be loading a message
		// let the server notify us if no message exists
		//   validation of hash is done server side
		if(typeof id != 'undefined')
		{
            var mString = '#' + user +
                (path != null && path != '' ? ('$' + path) : '') +
                '#' + id;
			$('.dialog').hide();
			$('.message').show();
			$('body').removeClass('menu');
            $('#results').remove();
            $('#search input').val('');

			// check if the message is already open, just switch to it
			if((message = $('.message a[href="' + mString + '"]')).length > 0)
			{
				var msg = message.parents('.message');
				msg.detach().appendTo($('#content'));
				if(msg.is('.compose') || msg.is('.contact'))
					$('#paging').hide();
			}
			
			// load compose mail from localStorage
			else if (path == '__--compose')
			{
				$('#paging').hide();
				composeMessage(user, path, id);
			}

            // view a contact
            else if (path == '__--contact')
            {
                var newMessage = loadContact(user, id),
                    cString = newMessage.find('thead tr:first-child th:nth-child(2) a').attr('href'),
                    cLink = $('#contacts a[href="' + cString + '"]');
                if(cLink.length == 0)
                    // request the contact info
                    getAccessCode(user, function (access, user) {
                        queueWork({
                            type: 'google',
                            request: {user: user, access: access, id: id},
                            result: function (response) {
                                newMessage.find('tbody pre').text(JSON.stringify(response[0].data, undefined, 4));
                                newMessage.find('tr:first-child th:nth-child(2) a span').text(response[0].title);
                            }
                        });
                    });
            }

			// load the message from the associated account
			else
				getAccessCode(user, function (access, user) {
					queueWork({
						type: 'mail', 
						request: {user:user, path: path, id: id, access:access}, 
						result: messageSuccess,
						loading: '#menubar'
					}); 
				});
		}
		else
			$('.message').hide();
	}
	
	function populateAccounts(j)
	{
		for(var i in accounts)
			j.append('<option value="' + accounts[i].user + '">' + accounts[i].user + '</option>');
	}
	window['populateAccounts'] = populateAccounts;
	
	function sendMessage(addresses, from, message, subject, which)
	{
		var publicKeys = [],
			keys = privateKeys,
			pubs = openpgp.keyring.publicKeys,
			unknowns = [],
			privateKey = null;
		
		// find private key for the selected sender
		for(var j in keys)
		{
			var key = openpgp.read_privateKey(keys[j])[0];
			// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
			if(key.userIds[0].text.indexOf(from) > -1)
			{
				privateKey = keys[j];
				break;
			}
		}
		
		// add all the recipients to the encrypted message
		for(var j in addresses)
		{
			var hit = false;
			for(var i in pubs)
			{
				if(pubs[i].obj.userIds[0].text.indexOf(addresses[j]) > -1)
				{
					publicKeys[publicKeys.length] = pubs[i].obj;
					hit = true;
					break;
				}
			}
			if(!hit)
			{
				unknowns[unknowns.length] = addresses[j];
			}
		}
		
		if(unknowns.length > 0)
		{
			// TODO: display a message when there are unknown recipients, ask to invite them
		}
		
		// TODO: fix plain text by iterating dom
		var request = {
			publicKeys: publicKeys,
			privateKey: privateKey,
			message: message,
			subject: subject,
			from: from,
			recipients: addresses
		};
		
		queueWork({type: 'send', request: request, result: 'sent', loading: which})
	}
	window['sendMessage'] = sendMessage;
	
	function addAccount(account)
	{
		var hit = false;
		for(var i in accounts)
		{
			if(accounts[i].user == account.user)
			{
				accounts[i].pass = account.pass;
				hit = true;
			}
		}
		if(!hit)
			accounts[accounts.length] = account;
		// store the accounts
		encryptAccounts();
	}
	
	function setBindings(scope)
	{
		if(scope == null)
			scope = $('body')
		
		scope.find('a[href="#folders"]').click(function (evt) {
			evt.preventDefault();
			$('#folders .selected').scrollintoview();
		});
		
		scope.find('a[href="#login-google"]').click(function (evt) {
			evt.preventDefault();
			doGoogleLogin();
		});
		
		scope.find('a[href="#keys"]').click(function () {
			// TODO: remove this, only offer a download uri, can that be called by a javascript and exploited?
			for(var i in accounts)
			{
				var fString = accounts[i].user;
				
				// only add account keys once
				if($('#keys .keys a[href="#' + fString + '"]').length > 0)
					continue;
				
				var email = $('<li><a href="#' + fString + '">' + fString + '</a></li>');
				email = email.appendTo($('#keys .keys ul'))
							 .find('a');
				email.click(function (evt) {
					evt.preventDefault();
					var fString = $(this).attr('href').substring(1);
					// do visual selection stuff
					$('#keys .selected').removeClass('selected');
					$(this).addClass('selected');
					
					// clear currently displayed key
					$('#key').val('');
					
					// find key in keyring that matches the email address
					// TODO: connect this to some backup or management server
					var keys = privateKeys,
						result = '';
					for(var j in keys)
					{
						var key = openpgp.read_privateKey(keys[j])[0];
						// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
						if(key.userIds[0].text.indexOf(fString) > -1)
						{
							result += (result != '' ? '\r\n' : '') + keys[j];
							break;
						}
					}
					
					keys = openpgp.keyring.publicKeys;
					for(var j in keys)
					{
						// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
						if(keys[j].obj.userIds[0].text.indexOf(fString) > -1)
						{
							result += (result != '' ? '\r\n' : '') + keys[j].armored;
							break;
						}
					}
					
					// if there are no keys, offer create button
					if(result == '')
					{
						$('#keys th:nth-child(2), #keys td:nth-child(2)').hide();
						$('#keys th:nth-child(3), #keys td:nth-child(3)').show();
					}
					else
					{
						$('#key').val(result);
						$('#keys th:nth-child(2), #keys td:nth-child(2)').show();
						$('#keys th:nth-child(3), #keys td:nth-child(3)').hide();
					}
				});
			
				// synchronize public keys for trusted users
			}
		});
		
		scope.find('a[href="#create-key"]').click(function (evt) {
			evt.preventDefault();
			var fString = $('#keys .selected').attr('href').substring(1),
				//salt = openpgp_crypto_getRandomBytes(8),
				request = { // TODO: make options on the #keys page out of these
					size: 2048,
					name: '<' + fString + '>'
					//pass: master,
				},
				keyResponse = function () {
					if(typeof data.privateKeyArmored != 'undefined')
					{
						privateKeys[privateKeys.length] = data.privateKeyArmored;
						// import result in to local keyring
						openpgp.keyring.importPublicKey(data.publicKeyArmored);
						encryptAccounts();

						// if the same userId is still selected, show the key text
						if($('#keys .selected').attr('href') == '#' + fString)
						{
							$('#key').val(data.publicKeyArmored + data.privateKeyArmored);
							$('#keys th:nth-child(2), #keys td:nth-child(2)').show();
							$('#keys th:nth-child(3), #keys td:nth-child(3)').hide();
						}
					}
				};
			
			queueWork({type: 'generate', request: request, result: keyResponse, loading: '#keys'})
		});
		
		scope.find('a[href="#login"]').click(function (evt) {
			// list google accounts on login page
			var aLink = null;
			for(var i in accounts)
			{
				if($('#login a[href="#' + accounts[i].user + '"]').length != 0)
					continue;
				
				if(accounts[i].user.match(/@gmail.com$/igm) != null)
					$('#accounts').append('<p><a href="#' + accounts[i].user + '" class="little-btn google">g</a>signed in as ' + accounts[i].user + '</p>');
				else
					$('#accounts').append('<p><a href="#' + accounts[i].user + '" class="little-btn imap">imap</a>signed in as ' + accounts[i].user + '</p>');
			}
		});
		
		scope.find('a[href="#write"]').click(function (evt) {
			evt.preventDefault();
			var firstId = function (user) {
					var id = 1,
						fString = '#' + user + 
						'$__--compose' + 
						'#' + id;
					while($('.message a[href="' + fString + '"]').length > 0 && typeof localStorage[fString] == 'undefined')
						id++;
					return id;
				};
			composeMessage(accounts[0].user, '__--compose', firstId(accounts[0].user));
		});
		
		scope.find('a[href="#login-other"]').click(function (evt) {
			evt.preventDefault();
	
			// encode as base64 and send to proxy
			//   TODO: can this be done in javascript and there is no need for a proxy?
			var $base64 = CryptoJS.enc.Latin1.parse($('#pass').val()).toString(CryptoJS.enc.Base64),
				email = $('#email').val();
			$.post('/login.php', {
				user:email,
				access:$base64
			}, function (data) {
				// save in accounts
				var account = {user: email, pass: $base64};
				addAccount(account);
				
				// load the new mailbox
				returnPath = '#' + account.user;
				window.location.hash = '#mail';
			})
			.fail(function (data) {
				master = null;
// TODO: display error message
				
			});
		});
	}
	
	function firstLoad()
	{
		openpgp.init(); //must call here :/  shouldn't it just do this when it's done loading?

		composeInterval = setInterval(function () {
			var last = $('.compose').last();
			if(last.length == 0)
				return;
            var headers = $('#menubar, .message thead'),
                editor = last.find('.jqte'),
                height = 0;
            headers.each(function () {
                height += $(this).outerHeight();
            })
            editor.css('min-height', $(window).innerHeight() - height);
		}, 100);
		queueInterval = setInterval(processQueue, 100);
		
		// initialize everything using functions from mail.js
		$(window).on('hashchange', checkHash);
		
		decryptAccounts(); // decrypt local account information
		
		var params = {}, 
			queryString = window.location.hash.substring(1),
			regex = /([^&=]+)=([^&]*)/g, m;
		while (m = regex.exec(queryString)) {
			params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
		}
		
		if(typeof params['state'] != 'undefined' &&
			params['state'] == 'initialGoogle')
			getGoogleUser(params, function (account) {
				addAccount(account);
				returnPath = '#' + account.user;
				window.location.hash = '#mail';
			});
		else
			returnPath = window.location.hash;
		
		if(accounts.length > 0)
			window.location.hash = '#mail';
		else
			window.location.hash = '#intro';
		
		// fire hash changed at least once
		$(window).trigger('hashchange');
					
		setBindings();

        $('#search input').val('').watermark('Search      ');
        $('#search input').keyup(function () {
            var search = $(this).val().trim(),
                results = $('#results'),
                matches = new RegExp(search, 'igm');
            if(search == '')
                $('#results').remove();
            if(results.length == 0)
                results = $('<ul id="results"></ul>').insertAfter($('#search'));
            else
                results.find('>*').remove();
            $('#nav ul li a').each(function () {
                if(matches.test($(this).text()))
                {
                    $(this).clone().html($(this).text()
                        .replace(matches, function (match) { return '<span class=\"highlight\">' + match + '</span>'; }))
                        .appendTo($('<li></li>').appendTo(results));
                }
            });
        });


		$('a[href="#menu"]').click(function (evt) {
			evt.preventDefault();
			$('body').toggleClass('menu');
		});
	}
	$(document).ready(function () {
		firstLoad();
	});
})();

function refreshBody(attachments)
{
	// TODO:  implement levels of trust for content
	// only make view/display decisions here, nothing to do with data structure
	
	for(var i in attachments)
	{
		var headers = attachments[i]['headers'],
			addresses = headers['part-id'].split('#'),
			message = $('.message a[href="#' + addresses[1] + '#' + addresses[2] + '"]').parents('.message'),
			// add parts to message
			part = message.find('.part[id="' + headers['part-id'] + '"]');
			
		if(part.length == 0)
			part = $('<div class="part" id="{part-id}"></div>'
				.replace(/\{part-id\}/igm, headers['part-id']))
				.appendTo(message.find('tbody td'));
		if(typeof headers['content-type'] != 'undefined')
			part.addClass(sanitizeName(headers['content-type']));
		
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'application/octet-stream')
		{
			// create a link to blob to download file
		}
		if(attachments[i]['headers']['content-type'] == 'pgp/mime')
		{
			// notify users that they have received and encrypted message
		}
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'text/plain')
		{
			// html encode
			var output = escapeHtml(attachments[i].body, true);
			// wrap in a pre tag
			part.html('<pre>' + output + '</pre>');
		}
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'text/html')
		{
			// assume html and just wrap in a div
			var output = sanitizeBody(attachments[i].body);
			part.html(output);
		}
		if(typeof headers['parameters'] != 'undefined' && (
			typeof headers['parameters']['name'] != 'undefined' ||
			typeof headers['parameters']['attachment'] != 'undefined' ||
			typeof headers['parameters']['filename'] != 'undefined'))
		{
			// add to DOM as attachment
			var filename = headers['parameters']['name'] || headers['parameters']['attachment'] || 
						   headers['parameters']['filename'];
			// display a save link to file
			var attachs = message.find('.attachments .' + sanitizeName(filename));
			if(attachs.length == 0)
				attachs = $('<div class="' + sanitizeName(filename) + '">' + filename + '<a href="' + headers['part-id'] + '">download</a></div>')
                    .appendTo(message.find('.attachments'));
		}
		
		// add encrypted loading symbol
		if(headers['part-id'].match(/#encrypted/igm) &&
			typeof headers['content-type'] != 'undefined' && (
			headers['content-type'] != 'text/plain' || 
			headers['content-type'] != 'text/html'))
		{
			if(message.find('.decrypting').length == 0 &&
				// TODO: don't display decrypting message should check some sort of queue that everything has been decrypted successfully
				message.find('.part[id*="#decrypted"]').length != 
				message.find('.part[id*="#encrypted"]').length)
				$('<div class="decrypting">decrypting...</div>').prependTo(message.find('.attachments'));
		}
		
		// remove encrypted loading symbol
		if(headers['part-id'].match(/#decrypted/igm) &&
			typeof headers['content-type'] != 'undefined' && (
			headers['content-type'] != 'text/plain' || 
			headers['content-type'] != 'text/html'))
		{
			if(message.find('.part[id*="#decrypted"]').length == 
				message.find('.part[id*="#encrypted"]').length)
			{
				message.find('.decrypting').remove();
			}
		}
		
		// add symbols for parts of message
		if(typeof headers['verified'] != 'undefined' &&
			headers['verified'] == false)
		{
			if(message.find('.verify-failed').length == 0)
				$('<tr><th class="verify-failed" colspan="3"><div>Signature varification failed.</div></th></tr>').appendTo(message.find('thead'))
		}
		
		// add decryption failed message here, just like above
		if(typeof headers['decrypt'] != 'undefined' &&
			headers['decrypt'] == false)
		{
			if(message.find('.decryption-failed').length == 0)
				$('<tr><th class="decryption-failed" colspan="3"><div>Decryption failed.</div></th></tr>').appendTo(message.find('thead'))
		}
		
		// select the best view based on trust level

	}
	
}

function loadingAnimation(that)
{
	if(typeof that != 'undefined' && that.find('.loading').length == 0)
	{
		return loadingAnimation.call($('<span class="loading">&nbsp;</span>').appendTo(that), that);
	}
	else if ($(this).is('.loading'))
		return $(this).css('width', 0).css('left', 0)
			.animate({width: $(this).parent().outerWidth(true)}, 1000, function () {
				$(this).animate({left: $(this).parent().outerWidth(true)}, 1000, loadingAnimation);
			});
	else if(typeof that != 'undefined')
		return that.find('.loading');
}

function closeMessage(evt)
{
	evt.preventDefault();
	var that = $(this),
		message = that.parents('.message'),
		fString = that.parents('tr').find('th:nth-child(2) a').attr('href'),
		prev = message.prev('.message');
	message.remove();
	$('#mail a[href="' + fString + '"]').removeClass('selected');
	if(prev.length == 0)
		prev = $('.message').last();
		
	// if we closed the last message, select the current folder
	if(prev.length == 0)
		window.location.hash = $('#folders .selected').attr('href');
	// if we haven't closed all the message, select the next one in order
	else if(window.location.hash == fString)
		window.location.hash = prev.find('thead th:nth-child(2) a').attr('href');
}

function messageSuccess(result)
{
	var path = result.info.mailbox,
		fString = '#' + result.user + '@' + result.host + 
				(path != '' ? ('$' + path) : '') + 
				'#' + result.headers.msgno,
		from = parseInlineEncoding(result.headers.from),
		newMessage = '<table class="message">' +
'<thead>' +
    '<tr><th><a class="little-btn" href="#close-message"><span class="close"></span></a></th>' +
        '<th><a href="{link}"><span>{from}</span>{subject}</a></th>' +
        '<th><div><a class="little-btn" href="#forward"><span class="forward"></span></a>' +
                 '<a class="little-btn" href="#reply-all"><span class="reply-all"></span></a>' +
                 '<a class="little-btn" href="#reply"><span class="reply"></span></a></div></th></tr>' +
    '<tr><th colspan="3">From: {fromfull}<br />Date: {date}<br />To: {to}</th></tr>' +
    '<tr><th colspan="3">{subject}</th></tr>' +
    '<tr><th colspan="3" class="attachments"><a href="#text_html">HTML</a><a href="#text_plain">PLAIN</a></th></tr>' +
'</thead>' +
'<tbody>' +
    '<tr>' +
        // get a blank html page with no logic to fill in with our values
        '<td colspan="3"></td>' +
    '</tr>' +
'</tbody>' +
'</table>';

	// remove extra information on from
	if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(parseInlineEncoding(from))))
		from = $match[2].trim();
	newMessage = newMessage.replace(/\{from\}/ig, escapeHtml(from))
						   .replace(/\{fromfull\}/ig, escapeHtml(parseInlineEncoding(result.headers.from)))
						   .replace(/\{subject\}/ig, escapeHtml(parseInlineEncoding(result.headers.subject)))
						   .replace(/\{date\}/ig, result.headers.date)
						   .replace(/\{to\}/ig, result.headers.to)
						   .replace(/\{link\}/ig, fString);
	newMessage = $(newMessage).appendTo($('#content'));
	newMessage.find('a[href="#close-message"]').click(closeMessage);
	newMessage.find('a[href="#reply"]').parent().parent().hover(function () {
        $(this).addClass('hover');
    }, function () {
        $(this).removeClass('hover');
    });
    newMessage.find('a[href="#text_plain"], a[href="#text_html"]')
        .click(function (evt) {
            evt.preventDefault();
            newMessage.find('.part').hide();
            newMessage.find('.part.' + $(this).attr('href').substring(1)).show();
        });
	// clean up the email data
	/*if(result.headers.size >= 4 * 1024 * 1024)
	{
		// the message is large, download with a worker
		getAccessCode(result.user + '@' + result.host, function (access) {
			var request = {
					user:result.user + '@' + result.host,
					path: path,
					access: access,
					id : result.headers.msgno,
					headers : {
						'part-id' : fString
					}
				};
			queueWork({type: 'download', request: request, result: refreshBody});
		});
		
	}
	else*/
	{
		if(typeof result.message == 'string')
		{
			var tmpResult = parseHeaders(result.message),
				message = tmpResult[0],
				headers = tmpResult[1];
			headers['part-id'] = fString + (typeof result.headers['part-id'] != 'undefined' ? result.headers['part-id'] : '');
			parseMIME(message, headers, refreshBody);
		}
		else
		{
			result.headers['part-id'] = fString + (typeof result.headers['part-id'] != 'undefined' ? result.headers['part-id'] : '');
			parseMIME('', result.headers, refreshBody);
		}
	}
}

// called whenever the page is first loaded and we need to
//   list the mail folders and headers for the selected folder
function mailSuccess(result)
{
	var folders = $('#folders'),
		mBox = result.info.mailbox.replace(/\{.*?\}(INBOX\.*)*/i, '').trim(),
		fString = result.user + '@' + result.host + (mBox == '' ? '' : '$') + mBox,
		accountRoot = folders.find('> li > a[href="#' + result.user + '@' + result.host + '"]').parent();

	// reload the folders from account
	if(typeof result.folders != 'undefined' && result.folders != null)
		loadFolders(result, accountRoot, result.folders);
	
	// if we just loaded the currently selected folder
	var dialog = window.location.hash,
		user = dialog.split('#')[1].split('$')[0],
		path = dialog.split('#')[1].split('$')[1],
		sString = user + (typeof path != 'undefined' && path != '__--compose' &&
                                 path != '__--contact' ? ('$' + path) : '');
	if($('#folders .selected').length == 0 && dialog == '#mail')
	{
		window.location.hash = sString = fString;
	}
	var selected = $('#folders a[href="#' + sString + '"]'),
		fLink = $('#folders a[href="#' + fString + '"]');
	if(fLink.length > 0)
	{
		fLink.text(fLink.text().replace(/\s+\([0-9]*\)\s*$/i, '') + ' (' + result.info.unseen + ')');
	}
	
	// load the headers in to the message list, 
	//   only when the headers are of the mailbox we selected
	//   like the scenario when we load all the folder first time the page loads
	//   or when the user selects a different folder while its loading
	if(selected.length > 0)
	{
		selected.addClass('selected').parents('ul').addClass('expand');
		selected.scrollintoview();
		if(sString == fString)
		{
			// set up paging
			$('#count').html('<b>' + (1+result.info.start) + '-' + result.info.end + '</b> of <b>' + result.info.messages + '</b>');
			loadHeaders(result, accountRoot, result.headers);
		}
	}
}

function loadFolders(result, accountRoot, folders)
{
	folders.sort(function (a, b) {
		return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
	});
	
	for(var i in folders)
	{
		// split by dot to create folder trees
		var subfolders = folders[i].name.split(folders[i].delim),
			current = accountRoot.children('ul'),
			fString = result.user + '@' + result.host + '$';
			
		// loop through each sub folder adding as we go
		for(var j in subfolders)
		{
			fString += (j > 0 ? '.' : '') + subfolders[j];
			var temp = current.find('> li > a[href="#' + fString + '"]').parent();
			if(temp.length == 0)
			{
				temp = $('<li><a href="#' + fString + '">' + subfolders[j] + '</a><ul></ul></li>')
				.appendTo(current);
				temp.find('> a')
				.click(function () {
					$(this).siblings('ul').toggleClass('expand');
				});
			}
			current = temp.children('ul');
		}
	}
}

function loadHeaders(result, accountRoot, headers)
{
	$('#mail a').remove();
	
	for(var header in headers)
	{
		if(!headers[header]) // skip messages that disappeared
			continue;
		if(typeof headers[header] == 'object')
		{
			var obj = headers[header],
				// this is the path directly to the message
				fString = '#' + result.user + '@' + result.host + 
						(result.info.mailbox != '' ? ('$' + result.info.mailbox) : '') + 
						'#' + obj.msgno,
				selected = $('.message a[href="' + fString + '"]').length > 0;
			
			if(obj.from == null)
				obj.from = '';
			else
				obj.from = parseInlineEncoding(obj.from);
			// remove extra information on from
			if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(obj.from)))
				obj.from = $match[2].trim();
			
			if(obj.subject == null)
				obj.subject = '';
			else
				obj.subject = parseInlineEncoding(obj.subject);
			
			var newRow = $('<a href="' + fString + '" class="' + (selected ? 'selected' : '') + '"><span>&nbsp;</span>' + 
				'<span>' + escapeHtml(obj.from) + '</span>' +
				'<span>' + escapeHtml(obj.subject) + '</span>' +
				'<span>' + obj.date + '</span></a>').appendTo($('#mail'));
			
			if(!(/\\seen/i).test(obj.flags))
				newRow.addClass('unseen');
		}
	}
}

function loadContact(user, id)
{
    var fString = '#' + user +
                  '$' + '__--contact' +
                  '#' + id,
        cLink = $('#contacts a[href="' + fString + '"]'),
        newMessage = '<table class="message contact">' +
'<thead>' +
    '<tr><th><a class="little-btn" href="#close-message"><span class="close"></span></a></th>' +
        '<th><a href="{link}"><span>{title}</span></a></th>' +
        '<th></th></tr>' +
'</thead>' +
'<tbody>' +
    '<tr>' +
        '<td colspan="3"><pre>{contact}</pre></td>' +
    '</tr>' +
'</tbody>' +
'</table>';
    newMessage = newMessage
        .replace(/\{link\}/ig, fString)
        .replace(/\{title\}/ig, cLink.length > 0 ? cLink.text() : '')
        .replace(/\{contact\}/ig, cLink.length > 0 ? JSON.stringify(cLink.data('data'), undefined, 4) : '');
    newMessage = $(newMessage).appendTo($('#content'));
    newMessage.find('a[href="#close-message"]').click(closeMessage);
    return newMessage;
}

function loadAccount(user)
{
    if($('#folders a[href="#' + user + '"]').length == 0)
    {
        var accountRoot = $('<li><a href="#' +  user + '">' + user + '</a><ul class="expand"></ul></li>')
            .appendTo(folders);
        accountRoot.find('> a')
            .click(function () {
                // uncomment to allow accountRoot to be minimized
                //$(this).siblings('ul').toggleClass('expand');
            });
        return true;
    }
    return false;
}

function composeMessage(user, path, id)
{
    var fString = '#' + user +
		          // TODO add Drafts? to directory here
		          '$' + path +
		          '#' + id,
		newMessage = '<table class="message compose">' +
'<thead>' + 
	'<tr><th><a class="little-btn" href="#close-message"><span class="close"></span></a></th>' + 
		'<th><a href="{link}"><span>New message</span></a></th>' + 
		'<th><a class="little-btn" href="#attach"><span class="attach"></span></a>' + 
			'<a class="little-btn" href="#format"><span class="format"></span></a>' + 
			'<a class="little-btn" href="#send"><span class="send">Send</span></a></th></tr>' + 
	'<tr><th colspan="2"><select class="from"></select></th>' + 
		'<th><a class="little-btn checked" href="#sign"><span class="pen">Sign</span></a>' + 
			'<a class="little-btn checked" href="#encrypt"><span class="key">Encrypt</span></a></th></tr>' + 
	'<tr><th colspan="3"><input class="recipients" type="email" /></th></tr>' + 
	'<tr><th colspan="3"><input class="subject" type="text" /></th></tr>' + 
'</thead>' + 
'<tbody>' + 
	'<tr>' + 
		'<td colspan="3"><textarea></textarea></td>' + 
	'</tr>' + 
'</tbody>' + 
'</table>';
	newMessage = newMessage.replace(/\{link\}/ig, fString);
	newMessage = $(newMessage).appendTo($('#content'));
	populateAccounts(newMessage.find('.from'));  // call a different scope to add users
	newMessage.find('.recipients').watermark('To      ');
	newMessage.find('.subject').watermark('Subject      ');
	newMessage.find('textarea').jqte();
	newMessage.find('a[href="#close-message"]').click(closeMessage);
	newMessage.find('a[href="#format"]').click(function (evt) {
			evt.preventDefault();
			$(this).toggleClass('checked');
			$(this).parents('.compose').find('.jqte').toggleClass('checked');
		});
	newMessage.find('a[href="#attach"]').click(function (evt) {
		evt.preventDefault();
	});
	newMessage.find('a[href="#send"]').click(function (evt) {
		evt.preventDefault();
		var compose = $(this).parents('.compose'),
			mString = compose.find('thead tr:first-child th:nth-child(2) a').attr('href');
		sendMessage(
			compose.find('.recipients').val().split(/\s*;\s*|\s*,\s*|\s+/igm),
			compose.find('select').val(),
			compose.find('textarea').val(),
			compose.find('.subject').val(),
			mString);
			
		compose.addClass('sending');
	});
	newMessage.find('a[href="#encrypt"]').click(function (evt) {
		evt.preventDefault();
		$(this).toggleClass('checked');
	});
	
	newMessage.find('a[href="#sign"]').click(function (evt) {
		evt.preventDefault();
		$(this).toggleClass('checked');
	});
	window.location.hash = fString;
}




