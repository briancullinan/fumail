// JavaScript Document

var dialog = null;
var show_count = 100; // TODO: setting within browser for paging
var returnPath = '';

// Use a closure so injection scripts cant get to these important variables, does this actually work?
// TODO: functions that take a callback and handle account information could expose closure to injection attacks
(function () {
	var accounts = null,
		master = null,
		privateKeys = null,
		workQueue = [],
		loadingStatus = {};
	
	function processQueue()
	{
		var requests = workQueue;
// TODO: some sort of prioritization here, if need be
		workQueue = [];
		if(requests.length == 0)
			return;
		$.Hive.create({
			worker: '/worker.js',
			count: requests.length,
			receive: function (data) {
				var worker = $.Hive.get(data.WORKER_ID),
					request = worker.request;
				if(console)
					console.log(data);
				// check for errors
				if(typeof data._status != 'undefined' && 
					data._status == 'done')
				{
					if(console)
						console.log('{' + data.WORKER_ID + '}' + data._status);
					if(typeof request.loading == 'string')
					{
						loadingStatus[request.loading] -= 1;
						if(loadingStatus[request.loading] == 0)
						{
							$(request.loading + ' .loading').remove();
						}
					}
					else if (typeof request.loading == 'object')
					{
						for(var i in request.loading)
						{
							loadingStatus[request.loading[i]] -= 1;
							if(loadingStatus[request.loading[i]] == 0)
							{
								$(request.loading[i] + ' .loading').stop().remove();
							}
						}
					}
// TODO: find out if not destroying causes memory issues
//					jQuery.Hive.destroy(worker);
				}
				else if(typeof data._status != 'undefined')
				{
					if(console)
						console.log('{' + data.WORKER_ID + '}' + data._status);
				}
				else
				{
					try {
						request.result.call(window, data);
					}
					catch (e)
					{
						if(console)
							console.log(e);
					}
				}
			},
			created: function ($hive) {
				if(console)
					console.log('starting: ' + $hive.length);
				for(var i in requests)
				{
					var request = requests[i],
						worker = $hive.pop();
					if(typeof request.loading == 'string')
					{
						if(typeof loadingStatus[request.loading] == 'undefined')
							loadingStatus[request.loading] = 1;
						else
							loadingStatus[request.loading] += 1;
						loadingAnimation($(request.loading));
					}
					else if (typeof request.loading  == 'object')
					{
						for(var j in request.loading)
						{
							if(typeof loadingStatus[request.loading[j]] == 'undefined')
								loadingStatus[request.loading[j]] = 1;
							else
								loadingStatus[request.loading[j]] += 1;
							loadingAnimation($(request.loading[j]));
						}
					}
					worker.request = request;
					$(worker).send({type: request.type, request: request.request});
				}
			}
		});
	}
	
	function queueWork(item)
	{
		workQueue.push(item);
	}
	window['queueWork'] = queueWork;
	
	function encryptAccounts()
	{
		if(master != null)
		{
			var serialized = JSON.stringify(accounts);
			var result = CryptoJS.TripleDES.encrypt(serialized, master);
			var encrypted = result.toString();
			localStorage['accounts'] = encrypted;
		}
		else
			localStorage['accounts'] = JSON.stringify(accounts);
		
		if(master != null)
		{
			// encrypt private keys
			serialized = JSON.stringify(privateKeys);
			result = CryptoJS.TripleDES.encrypt(serialized, master);
			encrypted = result.toString();
			localStorage['keys'] = encrypted;
		}
		else
			localStorage['keys'] = JSON.stringify(privateKeys);
	}
	
	function decryptAccounts()
	{
		var encrypted = localStorage['accounts'];
		if(typeof encrypted != 'undefined')
		{
			try {
				accounts = JSON.parse(encrypted);
			}
			catch (e) {
				try
				{
					var result = CryptoJS.TripleDES.decrypt(encrypted, master);
					var decrypted = result.toString(CryptoJS.enc.Latin1);
					accounts = JSON.parse(decrypted);
				}
				catch(e2)
				{
					// TODO:  failed to decrypt, do something here
					accounts = [];
				}
			}
		}
		else
			accounts = [];
		
		// decrypt keys too
		encrypted = localStorage['keys'];
		if(typeof encrypted != 'undefined')
		{
			try {
				privateKeys = JSON.parse(encrypted);
			}
			catch (e) {
				try
				{
					result = CryptoJS.TripleDES.decrypt(encrypted, master);
					decrypted = result.toString(CryptoJS.enc.Latin1);
					privateKeys = JSON.parse(decrypted);
				}
				catch(e2)
				{
					// TODO:  failed to decrypt, do something here
					privateKeys = [];
				}
			}
		}
		else
			privateKeys = [];
	}
	
	function getAccessCode(user, callback)
	{
		for(var i in accounts)
		{
			if(accounts[i].user == user)
			{
				if (accounts[i].user.match(/@gmail.com/igm) != null &&
					typeof accounts[i].expires != 'undefined' &&
					// check if a renewal is necessary
					accounts[i].expires < new Date().getTime())
				{
					doGoogleLogin(accounts[i].user /* immediately */, function (account) {
						accounts[i].user = account.user;
						accounts[i].access = account.access;
						accounts[i].expires = account.expires
						encryptAccounts();
						callback.call(this, account.access, user); 
						queueWork({type: 'google', request: accounts[i], result: getContactsSuccess});
					});
					return; // the callback will call this again instead
				}
				
				callback.call(this, accounts[i].pass || accounts[i].access, user);
				break;
			}
		}
	}
	
	function decryptWorker(request, resulted)
	{
		// TODO: nothing can scrape a web Worker right?
		request['keys'] = privateKeys;
		queueWork({type: 'decrypt', request: request, result: resulted});
	}
	window['decryptWorker'] = decryptWorker;
	
	function checkHash() 
	{
		if(window.location.hash == dialog)
			return;
			
		dialog = window.location.hash;
		var user = (dialog.split('#')[1] || '').split('$')[0],
			path = (dialog.split('#')[1] || '').split('$')[1],
			id = dialog.split('#')[2],
			folder = null;
			message = null,
			fString = '#' + user + 
				(typeof path != 'undefined' ? ('$' + path) : '');
	
		// drag and drop area
		var holder = document.getElementById('mail');
		// holder.ondragover = function () { this.className = 'hover'; return false; };
		// holder.ondragend = function () { this.className = ''; return false; };
		holder.ondragover = function () { 
			$('.compose iframe').each(function () {
				$(this).contents().find('body').addClass('dragging');
			});
			return false; 
		};
		holder.ondragend = function () { 
				$('.compose iframe').each(function () {
				$(this).contents().find('body').addClass('dragging');
			});
			return false;
		};
		
		holder.ondrop = function(e) {
			// this.className = '';
			e.preventDefault();
			
			var files = e.dataTransfer.files;
			for (var i = 0; i < files.length; i++) {
				handleFileDrop(files[i]);
			}
		};
		
		// if its emtpy show intro
		if(dialog == '')
		{
			$('.dialog').hide();
			$('#intro').show();
			$('.message').hide();
			$('#paging').hide();
			$('body').removeClass('menu');
			return;
		}
		
		// if it's mail, hide all dialogs and overlay
		if (dialog == '#mail')
		{
			$('.dialog').hide();
			$('#mail').show();
			$('.message').hide();
			$('#paging').show();
			$('body').removeClass('menu');
			
			if(!(returnPath == '' || returnPath == '#intro' ||
				returnPath == '#how' || returnPath == '#login' ||
				returnPath == '#mail' || returnPath == '#keys'))
			{
				window.location.hash = returnPath;
				return; // fall to no folders if this doesn't hit
			}
		}
		
		// try to match has to known dialog
		if(dialog == '#intro' || dialog == '#how' || 
			dialog == '#login' || dialog == '#keys')
		{
			$('.dialog').hide();
			$(dialog).show();
			$('.message').hide();
			$('#paging').hide();
			$('body').removeClass('menu');
			return;
		}
		
		// load mailboxes seperately
		if($('#folders a').length == 0)
		{
			for(var i in accounts)
			{
				// if the user is equal to what we typed in in the address bar, then also load the path
				if(user == accounts[i].user)
				{
					getAccessCode(accounts[i].user, function (access, user) { 
						queueWork({
							type: 'mail', 
							request: {user:user, path: path, access:access}, 
							result: mailSuccess,
							loading: '#menubar'
						}); 
					});
				}
				else
					getAccessCode(accounts[i].user, function (access, user) {
						queueWork({
							type: 'mail', 
							request: {user:user, path: '', access:access}, 
							result: mailSuccess,
							loading: '#menubar'
						}); 
					});
			}
		}
		
		// maybe the input is a folder
		else if((folder = $('#folders a[href="' + fString + '"]')).length > 0 && path != "__--compose")
		{
			$('.dialog').hide();
			$('#mail').show();
			$('#paging').show();
			$('body').removeClass('menu');
			// only do this if it is not selected, maybe just the message id changed, handled below
			if(!folder.is('.selected'))
			{
				var last = $('#folders .selected').removeClass('selected');
				if(!folder.parents('ul').is(last.find('~ ul')))
					last.find('~ ul').removeClass('expand');
				folder.addClass('selected');
				folder.scrollintoview();
				/*var offset = folder.offset();
				$('#folders').animate({
					scrollTop: offset.top - $('#folders').offset().top
				});
				*/
				getAccessCode(user, function (access, user) {
					queueWork({
						type: 'mail', 
						request: {user:user, path: path, access:access}, 
						result: mailSuccess,
						loading: ['#menubar', '#folders a[href="' + fString + '"]']
					}); 
				});
			}
			
			// select the header in the list
			if(typeof id != 'undefined' && 
				(message = $('a[href="' + fString + '#' + id + '"]')).length > 0)
			{
				// is the link referring to an exact message
				message.removeClass('unseen').addClass('selected');
				message.scrollintoview();
			}
		}
		
		// we may be loading a message
		// let the server notify us if no message exists
		//   validation of hash is done server side
		if(typeof id != 'undefined')
		{
			$('.dialog').hide();
			$('.message').show();
			$('body').removeClass('menu');
			
			// check if the message is already open, just switch to it
			if((message = $('.message a[href="' + fString + '#' + id + '"]')).length > 0)
			{
				var msg = message.parents('.message');
				msg.detach().appendTo($('#content'));
				if(msg.is('.compose'))
					$('#paging').hide();
			}
			
			// load compose mail from localStorage
			else if (path == '__--compose')
			{
				$('#paging').hide();
				composeMessage(user, path, id);
			}
			
			// load the message from the associated account
			else
				getAccessCode(user, function (access, user) {
					queueWork({
						type: 'mail', 
						request: {user:user, path: path, id: id, access:access}, 
						result: messageSuccess,
						loading: '#menubar'
					}); 
				});
		}
		else
			$('.message').hide();
	}
	
	function populateAccounts(j)
	{
		for(var i in accounts)
			j.append('<option value="' + accounts[i].user + '">' + accounts[i].user + '</option>');
	}
	window['populateAccounts'] = populateAccounts;
	
	function sendMessage(addresses, from, message, subject, which)
	{
		var publicKeys = [],
			keys = privateKeys,
			pubs = openpgp.keyring.publicKeys,
			unknowns = [],
			privateKey = null;
		
		// find private key for the selected sender
		for(var j in keys)
		{
			var key = openpgp.read_privateKey(keys[j])[0];
			// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
			if(key.userIds[0].text.indexOf(from) > -1)
			{
				privateKey = keys[j];
				break;
			}
		}
		
		// add all the recipients to the encrypted message
		for(var j in addresses)
		{
			var hit = false;
			for(var i in pubs)
			{
				if(pubs[i].obj.userIds[0].text.indexOf(addresses[j]) > -1)
				{
					publicKeys[publicKeys.length] = pubs[i].obj;
					hit = true;
					break;
				}
			}
			if(!hit)
			{
				unknowns[unknowns.length] = addresses[j];
			}
		}
		
		if(unknowns.length > 0)
		{
			// TODO: display a message when there are unknown recipients, ask to invite them
		}
		
		// TODO: fix plain text by iterating dom
		var request = {
			publicKeys: publicKeys,
			privateKey: privateKey,
			message: message,
			subject: subject,
			from: from,
			recipients: addresses
		};
		
		queueWork({type: 'send', request: request, result: 'sent', loading: which})
	}
	window['sendMessage'] = sendMessage;
	
	function setBindings(scope)
	{
		if(scope == null)
			scope = $('body')
		
		scope.find('a[href="#folders"]').click(function (evt) {
			evt.preventDefault();
			$('#folders .selected').scrollintoview();
		});
		
		scope.find('a[href="#login-google"]').click(function (evt) {
			evt.preventDefault();
			doGoogleLogin();
		});
		
		scope.find('a[href="#keys"]').click(function () {
			// TODO: remove this, only offer a download uri, can that be called by a javascript and exploited?
			for(var i in accounts)
			{
				var fString = accounts[i].user;
				
				// only add account keys once
				if($('#keys .keys a[href="#' + fString + '"]').length > 0)
					continue;
				
				var email = $('<li><a href="#' + fString + '">' + fString + '</a></li>');
				email = email.appendTo($('#keys .keys ul'))
							 .find('a');
				email.click(function (evt) {
					evt.preventDefault();
					var fString = $(this).attr('href').substring(1);
					// do visual selection stuff
					$('#keys .selected').removeClass('selected');
					$(this).addClass('selected');
					
					// clear currently displayed key
					$('#key').val('');
					
					// find key in keyring that matches the email address
					// TODO: connect this to some backup or management server
					var keys = privateKeys,
						result = '';
					for(var j in keys)
					{
						var key = openpgp.read_privateKey(keys[j])[0];
						// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
						if(key.userIds[0].text.indexOf(fString) > -1)
						{
							result += (result != '' ? '\r\n' : '') + keys[j];
							break;
						}
					}
					
					keys = openpgp.keyring.publicKeys;
					for(var j in keys)
					{
						// can a single key contain multiple user ids?  Maybe we just make a new FuMail key with all their account user Ids in one.
						if(keys[j].obj.userIds[0].text.indexOf(fString) > -1)
						{
							result += (result != '' ? '\r\n' : '') + keys[j].armored;
							break;
						}
					}
					
					// if there are no keys, offer create button
					if(result == '')
					{
						$('#keys th:nth-child(2), #keys td:nth-child(2)').hide();
						$('#keys th:nth-child(3), #keys td:nth-child(3)').show();
					}
					else
					{
						$('#key').val(result);
						$('#keys th:nth-child(2), #keys td:nth-child(2)').show();
						$('#keys th:nth-child(3), #keys td:nth-child(3)').hide();
					}
				});
			
				// synchronize public keys for trusted users
			}
		});
		
		scope.find('a[href="#create-key"]').click(function (evt) {
			evt.preventDefault();
			var fString = $('#keys .selected').attr('href').substring(1),
				//salt = openpgp_crypto_getRandomBytes(8),
				request = { // TODO: make options on the #keys page out of these
					size: 2048,
					name: '<' + fString + '>',
					//pass: master,
				},
				keyResponse = function () {
					if(typeof data.privateKeyArmored != 'undefined')
					{
						privateKeys[privateKeys.length] = data.privateKeyArmored;
						// import result in to local keyring
						openpgp.keyring.importPublicKey(data.publicKeyArmored);
						encryptAccounts();

						// if the same userId is still selected, show the key text
						if($('#keys .selected').attr('href') == '#' + fString)
						{
							$('#key').val(data.publicKeyArmored + data.privateKeyArmored);
							$('#keys th:nth-child(2), #keys td:nth-child(2)').show();
							$('#keys th:nth-child(3), #keys td:nth-child(3)').hide();
						}
					}
				};
			
			queueWork({type: 'generate', request: request, result: keyResponse, loading: '#keys'})
		});
		
		scope.find('a[href="#login"]').click(function (evt) {
			// list google accounts on login page
			var aLink = null;
			for(var i in accounts)
			{
				if($('#login a[href="#' + accounts[i].user + '"]').length != 0)
					continue;
				
				if(accounts[i].user.match(/@gmail.com$/igm) != null)
					$('#accounts').append('<p><a href="#' + accounts[i].user + '" class="little-btn google">g</a>signed in as ' + accounts[i].user + '</p>');
				else
					$('#accounts').append('<p><a href="#' + accounts[i].user + '" class="little-btn imap">imap</a>signed in as ' + accounts[i].user + '</p>');
			}
		});
		
		scope.find('a[href="#write"]').click(function (evt) {
			evt.preventDefault();
			var firstId = function (user) {
					var id = 1,
						fString = '#' + user + 
						'$__--compose' + 
						'#' + id;
					while($('.message a[href="' + fString + '"]').length > 0 && typeof localStorage[fString] == 'undefined')
						id++;
					return id;
				};
			composeMessage(accounts[0].user, '__--compose', firstId(accounts[0].user));
		});
		
		scope.find('a[href="#login-other"]').click(function (evt) {
			evt.preventDefault();
	
			// encode as base64 and send to proxy
			//   TODO: can this be done in javascript and there is no need for a proxy?
			var $base64 = CryptoJS.enc.Latin1.parse($('#pass').val()).toString(CryptoJS.enc.Base64),
				email = $('#email').val();
			$.post('/login.php', {
				user:email,
				access:$base64
			}, function (data) {
				window.location.hash = '#mail'; // causes dialog to hide
				
				// save in accounts
				var account = {user: email, pass: $base64},
					hit = false;
				for(var i in accounts)
				{
					if(accounts[i].user == account.user)
					{
						accounts[i].pass = account.pass;
						hit = true;
					}
				}
				if(!hit)
					accounts[accounts.length] = account;
				// store the accounts for the session
				encryptAccounts();
	
				// create another entry
				returnPath = '#' + account.user;
				window.location.hash = '#mail';
				// TODO: load the new mailbox?
			})
			.fail(function (data) {
				master = null;
// TODO: display error message
				
			});
		});
	}
	
	
	$(document).ready(function () {
		
		openpgp.init(); //must call here :/  shouldn't it just do this when it's done loading?
		
		setInterval(function () {
			var last = $('.compose .jqte').last();
			if(last.length == 0)
				return;
			var margin = last.outerHeight(true) - last.height();
			last.css('min-height', $(window).innerHeight() - margin - last.offset().top);
		}, 100);
		setInterval(processQueue, 100);
		
		// initialize everything using functions from mail.js
		$(window).on('hashchange', checkHash);
		
		decryptAccounts(); // decrypt local account information
		
		var params = {}, 
			queryString = window.location.hash.substring(1),
			regex = /([^&=]+)=([^&]*)/g, m;
		while (m = regex.exec(queryString)) {
			params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
		}
		
		if(typeof params['state'] != 'undefined')
			window[params['state']].call(this, params);
		else
			returnPath = window.location.hash;
		
		if(accounts.length > 0)
			window.location.hash = '#mail';
		else
			window.location.hash = '#intro';
		
		// fire hash changed at least once
		$(window).trigger('hashchange');
					
		setBindings();
		
		$('#search input').watermark('Search      ');
		
		$('a[href="#menu"]').click(function (evt) {
			evt.preventDefault();
			$('body').toggleClass('menu');
		});
	});
})();

function refreshBody(attachments)
{
	// TODO:  implement levels of trust for content
	// only make view/display decisions here, nothing to do with data structure
	
	// get the frame from the arguments passed in
	var append = true;
	if(typeof attachments == 'undefined')
	{
		var doc = this,
			frame = null;
		$('.message iframe').each(function ()
		{
			if($(this).contents().get()[0] == doc[0])
				frame = $(this);
		});
		
		attachments = frame.data('body') || [];
		append = false;
	}
	
	for(var i in attachments)
	{
		var headers = attachments[i]['headers'],
			addresses = headers['part-id'].split('#'),
			message = $('.message a[href="#' + addresses[1] + '#' + addresses[2] + '"]').parents('.message'),
			frame = message.find('iframe'),
			doc = frame.contents(),
			otherAttachments = frame.data('body') || [];
		
		if(append)
		{
			otherAttachments.unshift(attachments[i]);
			frame.data('body', otherAttachments);
		}
		
		// add parts to message
		var part = doc.find('.part[id="' + headers['part-id'] + '"]');
		if(part.length == 0)
			part = $('<div class="part" id="{part-id}"></div>'
				.replace(/\{part-id\}/igm, headers['part-id']))
				.appendTo(doc.find('body'));
		if(typeof headers['content-type'] != 'undefined')
			part.addClass(sanitizeName(headers['content-type']));
		
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'application/octet-stream')
		{
			// create a link to blob to download file
		}
		if(attachments[i]['headers']['content-type'] == 'pgp/mime')
		{
			// notify users that they have received and encrypted message
		}
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'text/plain')
		{
			// html encode
			var output = escapeHtml(attachments[i].body, true);
			// wrap in a pre tag
			part.html('<pre>' + output + '</pre>');
		}
		if(typeof headers['content-type'] != 'undefined' &&
			headers['content-type'] == 'text/html')
		{
			// assume html and just wrap in a div
			var output = sanitizeBody(attachments[i].body);
			part.html(output);
		}
		if(typeof headers['parameters'] != 'undefined' && (
			typeof headers['parameters']['name'] != 'undefined' ||
			typeof headers['parameters']['attachment'] != 'undefined' ||
			typeof headers['parameters']['filename'] != 'undefined'))
		{
			// add to DOM as attachment
			var filename = headers['parameters']['name'] || headers['parameters']['attachment'] || 
						   headers['parameters']['filename'];
			// display a save link to file
			var attachs = message.find('.attachments span.' + sanitizeName(filename));
			if(attachs.length == 0)
				attachs = $('<br /><span class="' + sanitizeName(filename) + '">' + filename + '</span>')
				.appendTo(message.find('.attachments'));
		}
		
		// add encrypted loading symbol
		if(headers['part-id'].match(/#encrypted/igm) &&
			typeof headers['content-type'] != 'undefined' && (
			headers['content-type'] != 'text/plain' || 
			headers['content-type'] != 'text/html'))
		{
			if(message.find('.decrypting').length == 0 &&
				// TODO: don't display decrypting message should check some sort of queue that everything has been decrypted successfully
				doc.find('.part[id*="#decrypted"]').length != 
				doc.find('.part[id*="#encrypted"]').length)
				$('<div class="decrypting">decrypting...</div>').prependTo(message.find('.attachments'));
		}
		
		// remove encrypted loading symbol
		if(headers['part-id'].match(/#decrypted/igm) &&
			typeof headers['content-type'] != 'undefined' && (
			headers['content-type'] != 'text/plain' || 
			headers['content-type'] != 'text/html'))
		{
			if(doc.find('.part[id*="#decrypted"]').length == 
				doc.find('.part[id*="#encrypted"]').length)
			{
				message.find('.decrypting').remove();
			}
		}
		
		// add symbols for parts of message
		if(typeof headers['verified'] != 'undefined' &&
			headers['verified'] == false)
		{
			if(message.find('.verify-failed').length == 0)
				$('<tr><th class="verify-failed" colspan="3"><div>Signature varification failed.</div></th></tr>').appendTo(message.find('thead'))
		}
		
		// add decryption failed message here, just like above
		if(typeof headers['decrypt'] != 'undefined' &&
			headers['decrypt'] == false)
		{
			if(message.find('.decryption-failed').length == 0)
				$('<tr><th class="decryption-failed" colspan="3"><div>Decryption failed.</div></th></tr>').appendTo(message.find('thead'))
		}
		
		// select the best view based on trust level
			
		// resize iframe when body size changes
		var safety = 10,
			content = frame.get()[0].contentWindow;
			J = content.$;
		if(typeof J == 'function' &&
			typeof content.resize == 'undefined')
		{
			content.resize = content.setInterval(function () {
				var height = 0; //J(content.document).outerHeight(true);
				if(typeof J != 'function')
					return;
				J('.part').each(function () {
					height += J(this).outerHeight(true);
				});
				frame.height(height + 100);
			}, 100);
		}
	}
	
}

function loadingAnimation(that)
{
	if(typeof that != 'undefined' && that.find('.loading').length == 0)
	{
		return loadingAnimation.call($('<span class="loading">&nbsp;</span>').appendTo(that), that);
	}
	else if ($(this).is('.loading'))
		return $(this).css('width', 0).css('left', 0)
			.animate({width: $(this).parent().outerWidth(true)}, 1000, function () {
				$(this).animate({left: $(this).parent().outerWidth(true)}, 1000, loadingAnimation);
			});
	else if(typeof that != 'undefined')
		return that.find('.loading');
}

function closeMessage(evt)
{
	evt.preventDefault();
	var that = $(this),
		message = that.parents('.message'),
		fString = that.parents('tr').find('th:nth-child(2) a').attr('href'),
		prev = message.prev('.message');
	message.remove();
	$('#mail a[href="' + fString + '"]').removeClass('selected');
	if(prev.length == 0)
		prev = $('.message').last();
		
	// if we closed the last message, select the current folder
	if(prev.length == 0)
		window.location.hash = $('#folders .selected').attr('href');
	// if we haven't closed all the message, select the next one in order
	else if(window.location.hash == fString)
		window.location.hash = prev.find('thead th:nth-child(2) a').attr('href');
}

function messageSuccess(result)
{
	var path = result.info.mailbox,
		fString = '#' + result.user + '@' + result.host + 
				(path != '' ? ('$' + path) : '') + 
				'#' + result.headers.msgno,
		from = parseInlineEncoding(result.headers.from),
		newMessage = '<table class="message">' +
	'<thead>' + 
		'<tr><th><a class="little-btn" href="#close-message"><span class="close"></span></a></th>' + 
			'<th><a href="{link}"><span>{from}</span>{subject}</a></th>' + 
			'<th><div><a class="little-btn" href="#forward"><span class="forward"></span></a>' + 
					 '<a class="little-btn" href="#reply-all"><span class="reply-all"></span></a>' + 
					 '<a class="little-btn" href="#reply"><span class="reply"></span></a></div></th></tr>' + 
		'<tr><th colspan="3">From: {fromfull}<br />Date: {date}<br />To: {to}</th></tr>' + 
		'<tr><th colspan="3">{subject}</th></tr>' + 
		'<tr><th colspan="3" class="attachments"><span>HTML</span><span>PLAIN</span></th></tr>' + 
	'</thead>' + 
	'<tbody>' + 
		'<tr>' + 
			// get a blank html page with no logic to fill in with our values
			'<td colspan="3"><iframe src="/mail.php" /></td>' + 
		'</tr>' + 
	'</tbody>' + 
'</table>';

	// remove extra information on from
	if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(parseInlineEncoding(from))))
		from = $match[2].trim();
	newMessage = newMessage.replace(/\{from\}/ig, escapeHtml(from))
						   .replace(/\{fromfull\}/ig, escapeHtml(parseInlineEncoding(result.headers.from)))
						   .replace(/\{subject\}/ig, escapeHtml(parseInlineEncoding(result.headers.subject)))
						   .replace(/\{date\}/ig, result.headers.date)
						   .replace(/\{to\}/ig, result.headers.to)
						   .replace(/\{link\}/ig, fString);
	newMessage = $(newMessage).appendTo($('#content'));
	newMessage.find('a[href="#close-message"]').click(closeMessage);
	newMessage.find('a[href="#reply"]').parent().parent().hover(function () {
			$(this).addClass('hover');
		}, function () {
			$(this).removeClass('hover');
		});
	// clean up the email data
	/*if(result.headers.size >= 4 * 1024 * 1024)
	{
		// the message is large, download with a worker
		getAccessCode(result.user + '@' + result.host, function (access) {
			var request = {
					user:result.user + '@' + result.host,
					path: path,
					access: access,
					id : result.headers.msgno,
					headers : {
						'part-id' : fString
					}
				};
			queueWork({type: 'download', request: request, result: refreshBody});
		});
		
	}
	else*/
	{
		if(typeof result.message == 'string')
		{
			var tmpResult = parseHeaders(result.message),
				message = tmpResult[0],
				headers = tmpResult[1];
			headers['part-id'] = fString + (typeof result.headers['part-id'] != 'undefined' ? result.headers['part-id'] : '');
			parseMIME(message, headers, refreshBody);
		}
		else
		{
			result.headers['part-id'] = fString + (typeof result.headers['part-id'] != 'undefined' ? result.headers['part-id'] : '');
			parseMIME('', result.headers, refreshBody);
		}
	}
}

// called whenever the page is first loaded and we need to
//   list the mail folders and headers for the selected folder
function mailSuccess(result)
{
	var folders = $('#folders'),
		mBox = result.info.mailbox.replace(/\{.*?\}(INBOX\.*)*/i, '').trim(),
		fString = result.user + '@' + result.host + (mBox == '' ? '' : '$') + mBox;

	// don't add accountRoot again if it is already in the list
	var accountRoot = folders.find('> li > a[href="#' + result.user + '@' + result.host + '"]');
	if(accountRoot.length == 0) 
	{
		accountRoot = $('<li><a href="#' + result.user + '@' + result.host + '">' + result.user + '@' + result.host + '</a><ul class="expand"></ul></li>')
		.appendTo(folders);
		accountRoot.find('> a')
		.click(function () {
			// uncomment to allow accountRoot to be minimized
			//$(this).siblings('ul').toggleClass('expand');
		});
	}
	
	// reload the folders from account
	if(typeof result.folders != 'undefined' && result.folders != null)
		loadFolders(result, accountRoot, result.folders);
	
	// if we just loaded the currently selected folder
	var dialog = window.location.hash,
		user = dialog.split('#')[1].split('$')[0],
		path = dialog.split('#')[1].split('$')[1],
		sString = user + (typeof path != 'undefined' ? ('$' + path) : '');
	if($('#folders .selected').length == 0 && dialog == '#mail')
	{
		window.location.hash = sString = fString;
	}
	var selected = $('#folders a[href="#' + sString + '"]'),
		fLink = $('#folders a[href="#' + fString + '"]');
	if(fLink.length > 0)
	{
		fLink.text(fLink.text().replace(/\s+\([0-9]*\)\s*$/i, '') + ' (' + result.info.unseen + ')');
	}
	
	// load the headers in to the message list, 
	//   only when the headers are of the mailbox we selected
	//   like the scenario when we load all the folder first time the page loads
	//   or when the user selects a different folder while its loading
	if(selected.length > 0)
	{
		selected.addClass('selected').parents('ul').addClass('expand');
		selected.scrollintoview();
		if(sString == fString)
		{
			// set up paging
			$('#count').html('<b>' + (1+result.info.start) + '-' + result.info.end + '</b> of <b>' + result.info.messages + '</b>');
			loadHeaders(result, accountRoot, result.headers);
		}
	}
}

function loadFolders(result, accountRoot, folders)
{
	folders.sort(function (a, b) {
		return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
	});
	
	for(var i in folders)
	{
		// split by dot to create folder trees
		var subfolders = folders[i].name.split(folders[i].delim),
			current = accountRoot.children('ul'),
			fString = result.user + '@' + result.host + '$';
			
		// loop through each sub folder adding as we go
		for(var j in subfolders)
		{
			fString += (j > 0 ? '.' : '') + subfolders[j];
			var temp = current.find('> li > a[href="#' + fString + '"]').parent();
			if(temp.length == 0)
			{
				temp = $('<li><a href="#' + fString + '">' + subfolders[j] + '</a><ul></ul></li>')
				.appendTo(current);
				temp.find('> a')
				.click(function () {
					$(this).siblings('ul').toggleClass('expand');
				});
			}
			current = temp.children('ul');
		}
	}
}

function loadHeaders(result, accountRoot, headers)
{
	$('#mail a').remove();
	
	for(var header in headers)
	{
		if(!headers[header]) // skip messages that disappeared
			continue;
		if(typeof headers[header] == 'object')
		{
			var obj = headers[header],
				// this is the path directly to the message
				fString = '#' + result.user + '@' + result.host + 
						(result.info.mailbox != '' ? ('$' + result.info.mailbox) : '') + 
						'#' + obj.msgno,
				selected = $('.message a[href="' + fString + '"]').length > 0;
			
			if(obj.from == null)
				obj.from = '';
			else
				obj.from = parseInlineEncoding(obj.from);
			// remove extra information on from
			if(($match = new RegExp(/^\s*("?)(.*)\1\s+<.*>\s*$/).exec(obj.from)))
				obj.from = $match[2].trim();
			
			if(obj.subject == null)
				obj.subject = '';
			else
				obj.subject = parseInlineEncoding(obj.subject);
			
			var newRow = $('<a href="' + fString + '" class="' + (selected ? 'selected' : '') + '"><span>&nbsp;</span>' + 
				'<span>' + escapeHtml(obj.from) + '</span>' +
				'<span>' + escapeHtml(obj.subject) + '</span>' +
				'<span>' + obj.date + '</span></a>').appendTo($('#mail'));
			
			if(!(/\\seen/i).test(obj.flags))
				newRow.addClass('unseen');
		}
	}
}

function composeMessage(user, path, id)
{
var fString = '#' + user + 
		// TODO add reply to directory here
		'$' + path + 
		'#' + id,
		newMessage = '<table class="message compose">' +
'<thead>' + 
	'<tr><th><a class="little-btn" href="#close-message"><span class="close"></span></a></th>' + 
		'<th><a href="{link}"><span>New message</span></a></th>' + 
		'<th><a class="little-btn" href="#attach"><span class="attach"></span></a>' + 
			'<a class="little-btn" href="#format"><span class="format"></span></a>' + 
			'<a class="little-btn" href="#send"><span class="send">Send</span></a></th></tr>' + 
	'<tr><th colspan="2"><select class="from"></select></th>' + 
		'<th><a class="little-btn checked" href="#sign"><span class="pen">Sign</span></a>' + 
			'<a class="little-btn checked" href="#encrypt"><span class="key">Encrypt</span></a></th></tr>' + 
	'<tr><th colspan="3"><input class="recipients" type="email" /></th></tr>' + 
	'<tr><th colspan="3"><input class="subject" type="text" /></th></tr>' + 
'</thead>' + 
'<tbody>' + 
	'<tr>' + 
		'<td colspan="3"><textarea></textarea></td>' + 
	'</tr>' + 
'</tbody>' + 
'</table>';
	newMessage = newMessage.replace(/\{link\}/ig, fString);
	newMessage = $(newMessage).appendTo($('#content'));
	populateAccounts(newMessage.find('.from'));  // call a different scope to add users
	newMessage.find('.recipients').watermark('To      ');
	newMessage.find('.subject').watermark('Subject      ');
	newMessage.find('textarea').jqte();
	newMessage.find('a[href="#close-message"]').click(closeMessage);
	newMessage.find('a[href="#format"]').click(function (evt) {
			evt.preventDefault();
			$(this).toggleClass('checked');
			$(this).parents('.compose').find('.jqte').toggleClass('checked');
		});
	newMessage.find('a[href="#attach"]').click(function (evt) {
		evt.preventDefault();
	});
	newMessage.find('a[href="#send"]').click(function (evt) {
		evt.preventDefault();
		var compose = $(this).parents('.compose'),
			mString = compose.find('thead tr:first-child th:nth-child(2) a').attr('href');
		sendMessage(
			compose.find('.recipients').val().split(/\s*;\s*|\s*,\s*|\s+/igm),
			compose.find('select').val(),
			compose.find('textarea').val(),
			compose.find('.subject').val(),
			mString);
			
		compose.addClass('sending');
	});
	newMessage.find('a[href="#encrypt"]').click(function (evt) {
		evt.preventDefault();
		$(this).toggleClass('checked');
	});
	
	newMessage.find('a[href="#sign"]').click(function (evt) {
		evt.preventDefault();
		$(this).toggleClass('checked');
	});
	window.location.hash = fString;
}


